local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

-- 初始化玩家
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- 获取远程事件
local GatherQiEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("GatherQi")
local BreakthroughEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Breakthrough")
local CraftPillEvent = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("CraftPill")

-- 核心配置
local CONFIG = {
    -- 草药采摘配置
    FLY_HEIGHT = 750,
    NORMAL_HEIGHT_OFFSET = 5,
    FLY_SPEED = 120,
    MOVE_TIMEOUT = 35,
    MOVE_DISTANCE_THRESHOLD = 4,
    HEIGHT_TWEEN_TIME = 0.7,
    HERBS_FOLDER_NAME = "Herbs",
    COLLECT_TIMEOUT = 15,
    MAX_RETRY_ATTEMPTS = 3,
    FLIGHT_STABILIZATION = 0.95,
    TIMEOUT_COOLDOWN = 30,
    MAX_PRIORITY_HERBS = 5,
    UI_UPDATE_INTERVAL = 1,
    
    -- 修炼配置
    BREAKTHROUGH_INTERVAL = 3,

    -- 新增黑名单配置
    BLACKLIST_HERBS = {
        "Herbicide"  -- 除草剂，永不采集
    },

    -- 炼药配置
    PILL_TYPES = {
        "Blood Qi",
        "Qi Spirit",
        "Qi Gathering", 
        "Bottleneck Breaking",
        "Extreme Yin",
        "Extreme Yang",
        "Mirror Heart",
        "Extreme Yin Yang",
        "Soul Bead"
    },
    
    -- UI配置
    UI_SCALE = {
        MAIN_FRAME_WIDTH = 550,
        MAIN_FRAME_HEIGHT = 400,
        TAB_BUTTON_WIDTH = 120,
        TAB_BUTTON_HEIGHT = 40,
        PRIORITY_FRAME_WIDTH = 450,
        PRIORITY_FRAME_HEIGHT = 500,
        TITLE_TEXT_SIZE = 18,
        SUBTITLE_TEXT_SIZE = 14,
        BODY_TEXT_SIZE = 12,
        SMALL_TEXT_SIZE = 10,
        BUTTON_HEIGHT = 32,
        BUTTON_TEXT_SIZE = 14,
        HERB_ITEM_HEIGHT = 35,
        PADDING_SMALL = 8,
        PADDING_MEDIUM = 12,
        PADDING_LARGE = 16,
    }
}

local AntiAFKState = {
    isRunning = true,
    connection = nil,
    lastInputTime = tick(),
    antiAFKInterval = 55, -- 55秒执行一次，确保在60秒AFK判定前触发
    errorCount = 0,
    maxErrorCount = 10,
    useSimulatedInput = true, -- 是否使用模拟输入
    useRemoteEvent = true, -- 是否使用远程事件
    lastAFKSignalTime = 0,
    afkSignalInterval = 30 -- 每30秒发送一次活动信号
}


-- 草药采摘状态
local HerbState = {
    isRunning = false,
    currentHerb = nil,
    IsFlying = false,
    FlightBodyVelocity = nil,
    FlightBodyGyro = nil,
    FlightConnection = nil,
    collectedHerbs = {},
    timeoutHerbs = {},
    retryAttempts = 0,
    OriginalGravity = workspace.Gravity,
    currentTimeoutCount = 0,
    herbAgeCache = {},
    failCount = 0,
    priorityHerbs = {},
    availableHerbTypes = {},
    isPriorityUIOpen = false,
    mainLoopCoroutine = nil,
    collectHerbs = true,  -- 是否采集草药
    collectAuras = true,  -- 是否采集功法
    targetMode = "both",   -- 目标模式: both, herb, aura
    quickPickEnabled = false,  -- 一键加速开关
    autoHarvestEnabled = false,  -- 自动采摘开关
    autoHarvestConnection = nil,  -- 自动采摘连接
    modifiedHerbs = {},  -- 已修改采摘时间的草药记录
    herbsFolderListener = nil,  -- 草药文件夹监听器
    quickPickConnection = nil  -- 一键加速连接器
}

local AuraAutoCollectState = {
    enabled = false,  -- 是否启用功法自动收集
    connection = nil,  -- 连接器
    lastCollectTime = 0,
    collectInterval = 0.5,  -- 收集间隔（秒） - 从0.5改为0.1
    maxDistance = 15,  -- 最大收集距离 - 从10改为15
}

-- 碰撞禁用状态 - 修复：使用表存储碰撞状态和已处理的对象
local CollisionState = {
    isCollisionDisabled = false,
    processedParts = {},  -- 存储已处理的部分
    partConnections = {},  -- 存储连接
    collisionListener = nil,  -- 碰撞监听器
    collisionReapplyTimer = nil,  -- 重新应用碰撞的计时器
    originalCollisionStates = {}  -- 存储原始的碰撞状态
}

-- 功法状态
local AuraState = {
    currentAura = nil,
    aurasFolderName = "Auras"
}

-- 修炼状态
local CultState = {
    isCultivating = false,
    isAutoBreakthrough = false,
    breakthroughConnection = nil,
    lastBreakthroughTime = 0
}

-- 炼药状态
local PillState = {
    isCrafting = false,
    currentPillType = "Qi Spirit",
    craftCount = 1,
    craftInterval = 3, -- 炼药间隔时间（秒）
    craftConnection = nil,
    isPillUIOpen = false
}

-- ===================== 修复：地图碰撞禁用功能 =====================
local function disableAllCollisionInMap()
    local mapFolder = Workspace:FindFirstChild("Map")
    
    if not mapFolder then
        print("[碰撞修改] 错误: 未找到 Map 文件夹")
        return false
    end
    
    print("[碰撞修改] 开始修改 Map 文件夹中的所有碰撞属性...")
    
    local processedCount = 0
    
    -- 清理之前的原始碰撞状态记录
    CollisionState.originalCollisionStates = {}
    
    -- 递归遍历文件夹及其所有子对象
    local function processFolder(folder)
        if not folder then return end
        
        for _, item in ipairs(folder:GetChildren()) do
            -- 如果是 BasePart 类型且有 CanCollide 属性，则设置为 false
            if item:IsA("BasePart") then
                -- 保存原始碰撞状态
                CollisionState.originalCollisionStates[item] = item.CanCollide
                item.CanCollide = false
                processedCount = processedCount + 1
                
                -- 监听碰撞属性的变化
                local connection = item:GetPropertyChangedSignal("CanCollide"):Connect(function()
                    if item.CanCollide == true then
                        -- print(string.format("[碰撞修改] 检测到碰撞恢复: %s，重新禁用", item.Name))
                        item.CanCollide = false
                    end
                end)
                
                -- 保存连接
                table.insert(CollisionState.partConnections, connection)
                
                if processedCount % 100 == 0 then
                    print(string.format("[碰撞修改] 已处理 %d 个对象...", processedCount))
                end
            end
            
            -- 如果是文件夹、Model或其他容器类型，则递归遍历其子对象
            if item:IsA("Folder") or item:IsA("Model") or item:IsA("BaseScript") then
                processFolder(item)
            end
        end
    end
    
    processFolder(mapFolder)
    print(string.format("[碰撞修改] 完成！已处理 %d 个对象的 CanCollide 属性设置为 false", processedCount))
    
    -- 设置碰撞监听器，监听新添加的对象
    if not CollisionState.collisionListener then
        CollisionState.collisionListener = mapFolder.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("BasePart") then
                task.wait(0.5) -- 等待对象完全加载
                
                -- 保存原始碰撞状态
                CollisionState.originalCollisionStates[descendant] = descendant.CanCollide
                descendant.CanCollide = false
                -- print(string.format("[碰撞修改] 新对象已禁用碰撞: %s", descendant.Name))
                
                -- 监听新对象的碰撞变化
                local connection = descendant:GetPropertyChangedSignal("CanCollide"):Connect(function()
                    if descendant.CanCollide == true then
                        -- print(string.format("[碰撞修改] 检测到新对象碰撞恢复: %s，重新禁用", descendant.Name))
                        descendant.CanCollide = false
                    end
                end)
                
                table.insert(CollisionState.partConnections, connection)
            end
        end)
    end
    
    -- 更新碰撞状态
    CollisionState.isCollisionDisabled = true
    print("[碰撞修改] 碰撞禁用状态已记录")
    
    return true
end

-- ===================== 修复：重新启用碰撞（如果需要） =====================
local function enableAllCollisionInMap()
    print("[碰撞恢复] 开始恢复地图碰撞...")
    
    -- 断开所有连接
    if CollisionState.collisionListener then
        CollisionState.collisionListener:Disconnect()
        CollisionState.collisionListener = nil
    end
    
    if CollisionState.collisionReapplyTimer then
        CollisionState.collisionReapplyTimer:Disconnect()
        CollisionState.collisionReapplyTimer = nil
    end
    
    for _, connection in ipairs(CollisionState.partConnections) do
        connection:Disconnect()
    end
    
    -- 恢复原始碰撞状态
    local restoredCount = 0
    for part, originalState in pairs(CollisionState.originalCollisionStates) do
        if part and part.Parent then
            part.CanCollide = originalState
            restoredCount = restoredCount + 1
        end
    end
    
    -- 清空状态
    CollisionState.processedParts = {}
    CollisionState.partConnections = {}
    CollisionState.originalCollisionStates = {}
    CollisionState.isCollisionDisabled = false
    
    print(string.format("[碰撞恢复] 已恢复 %d 个对象的碰撞属性", restoredCount))
    
    return true
end

-- ===================== 防AFK功能 =====================
-- 保存原来的远程事件引用
local InteractRemoteEvent = nil

local function setupAntiAFK()
    print("[防AFK] 启动防AFK系统")
    
    -- 查找远程事件
    if not InteractRemoteEvent then
        local RemotesFolder = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
        if RemotesFolder then
            InteractRemoteEvent = RemotesFolder:WaitForChild("Interact")
            if InteractRemoteEvent then
                print("[防AFK] 找到远程事件: Interact")
            else
                print("[防AFK] 警告: 未找到Interact远程事件")
            end
        else
            print("[防AFK] 警告: 未找到Remotes文件夹")
        end
    end
    
    -- 如果已经存在连接，先断开
    if AntiAFKState.connection then
        AntiAFKState.connection:Disconnect()
        AntiAFKState.connection = nil
    end
    
    AntiAFKState.isRunning = true
    AntiAFKState.errorCount = 0
    AntiAFKState.lastInputTime = tick()
    AntiAFKState.lastAFKSignalTime = tick()
    
    -- 使用连接器来持续运行防AFK
    AntiAFKState.connection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        
        -- 方法1: 使用VirtualUser模拟鼠标点击（每55秒一次）
        if AntiAFKState.useSimulatedInput and currentTime - AntiAFKState.lastInputTime >= AntiAFKState.antiAFKInterval then
            local success, errorMsg = pcall(function()
                if VirtualUser then
                    -- 模拟鼠标点击
                    VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                    task.wait(0.1)
                    VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
                    
                    AntiAFKState.lastInputTime = currentTime
                    print("[防AFK] 模拟鼠标点击已执行 - " .. os.date("%H:%M:%S"))
                    
                    -- 重置错误计数
                    AntiAFKState.errorCount = 0
                else
                    warn("[防AFK] VirtualUser 服务不可用")
                end
            end)
            
            if not success then
                AntiAFKState.errorCount = AntiAFKState.errorCount + 1
                print("[防AFK] 模拟鼠标点击失败: " .. tostring(errorMsg))
            end
        end
        
        -- 方法2: 直接发送远程事件（每30秒一次）
        if AntiAFKState.useRemoteEvent and currentTime - AntiAFKState.lastAFKSignalTime >= AntiAFKState.afkSignalInterval then
            local success, errorMsg = pcall(function()
                if InteractRemoteEvent then
                    -- 发送"Active"信号给服务器
                    InteractRemoteEvent:FireServer("Active")
                    
                    AntiAFKState.lastAFKSignalTime = currentTime
                    print("[防AFK] 发送活动信号到服务器 - " .. os.date("%H:%M:%S"))
                    
                    -- 重置错误计数
                    AntiAFKState.errorCount = 0
                else
                    -- 如果找不到远程事件，尝试重新查找
                    local RemotesFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Remotes")
                    if RemotesFolder then
                        InteractRemoteEvent = RemotesFolder:FindFirstChild("Interact")
                        if InteractRemoteEvent then
                            print("[防AFK] 重新找到远程事件: Interact")
                        end
                    end
                end
            end)
            
            if not success then
                AntiAFKState.errorCount = AntiAFKState.errorCount + 1
                print("[防AFK] 发送活动信号失败: " .. tostring(errorMsg))
            end
        end
        
        -- 如果错误太多，尝试重置
        if AntiAFKState.errorCount >= AntiAFKState.maxErrorCount then
            print("[防AFK] 错误过多，尝试重置防AFK系统")
            
            -- 断开当前连接
            if AntiAFKState.connection then
                AntiAFKState.connection:Disconnect()
                AntiAFKState.connection = nil
            end
            
            -- 等待1秒后重新启动
            task.wait(1)
            
            -- 重新启动防AFK
            setupAntiAFK()
        end
    end)
    
    print("[防AFK] 防AFK系统已启动")
    print("[防AFK] 策略1: 模拟鼠标点击 (间隔: " .. AntiAFKState.antiAFKInterval .. "秒)")
    print("[防AFK] 策略2: 发送活动信号 (间隔: " .. AntiAFKState.afkSignalInterval .. "秒)")
    
    -- 返回一个可以停止的函数（但正常情况下不会调用）
    local function stopAntiAFK()
        print("[防AFK] 停止防AFK系统")
        AntiAFKState.isRunning = false
        
        if AntiAFKState.connection then
            AntiAFKState.connection:Disconnect()
            AntiAFKState.connection = nil
        end
        
        print("[防AFK] 防AFK系统已停止")
    end
    
    -- 添加一个自动重启机制，以防连接意外断开
    local function checkAndRestartAntiAFK()
        while AntiAFKState.isRunning do
            task.wait(30) -- 每30秒检查一次
            
            if AntiAFKState.isRunning and not AntiAFKState.connection then
                print("[防AFK] 检测到防AFK连接断开，正在重新启动...")
                setupAntiAFK()
            end
        end
    end
    
    -- 启动检查线程
    task.spawn(checkAndRestartAntiAFK)
    
    return stopAntiAFK
end

-- ===================== 连接到游戏的输入事件，更新最后活动时间 =====================
local function setupGameInputMonitoring()
    print("[防AFK] 设置游戏输入监控")
    
    local lastGameInteractionTime = tick()
    
    -- 监控游戏的所有输入事件
    local function updateInteractionTime()
        lastGameInteractionTime = tick()
        AntiAFKState.lastInputTime = tick() -- 同时更新防AFK的输入时间
    end
    
    -- 连接到输入变化事件
    game:GetService("UserInputService").InputChanged:Connect(function()
        updateInteractionTime()
    end)
    
    -- 连接到输入开始事件
    game:GetService("UserInputService").InputBegan:Connect(function()
        updateInteractionTime()
    end)
    
    -- 检查是否需要发送活动信号
    local checkConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        local timeDifference = currentTime - lastGameInteractionTime
        
        -- 如果超过50秒没有活动（比60秒提前10秒）
        if timeDifference > 50 then
            -- 检查是否需要发送活动信号
            if currentTime - AntiAFKState.lastAFKSignalTime > 30 then
                local success, errorMsg = pcall(function()
                    if InteractRemoteEvent then
                        InteractRemoteEvent:FireServer("Active")
                        AntiAFKState.lastAFKSignalTime = currentTime
                        print("[输入监控] 超过50秒无活动，发送活动信号 - " .. os.date("%H:%M:%S"))
                    end
                end)
                
                if not success then
                    print("[输入监控] 发送活动信号失败: " .. tostring(errorMsg))
                end
            end
        end
    end)
    
    print("[防AFK] 游戏输入监控已启动")
    return checkConnection
end

-- ===================== 修炼功能 =====================
local function toggleCultivation()
    local xiulian = player:GetAttribute("Gathering")
    
    if xiulian == true then
        print("[修炼] 已在修炼状态，退出修炼")
        GatherQiEvent:FireServer()
        CultState.isCultivating = false
    else
        print("[修炼] 未在修炼状态，进入修炼")
        GatherQiEvent:FireServer()
        CultState.isCultivating = true
    end
    
    return CultState.isCultivating
end

local function startAutoBreakthrough()
    if CultState.isAutoBreakthrough then
        print("[突破] 自动突破已在运行中")
        return
    end
    
    CultState.isAutoBreakthrough = true
    CultState.lastBreakthroughTime = 0
    
    if CultState.breakthroughConnection then
        CultState.breakthroughConnection:Disconnect()
        CultState.breakthroughConnection = nil
    end
    
    CultState.breakthroughConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - CultState.lastBreakthroughTime >= CONFIG.BREAKTHROUGH_INTERVAL then
            CultState.lastBreakthroughTime = currentTime
            
            if CultState.isCultivating then
                BreakthroughEvent:FireServer()
                print("[突破] 发送突破请求")
            else
                print("[突破] 未在修炼状态，跳过突破")
            end
        end
    end)
    
    print("[突破] 自动突破已启动（间隔: " .. CONFIG.BREAKTHROUGH_INTERVAL .. "秒）")
end

local function stopAutoBreakthrough()
    if not CultState.isAutoBreakthrough then
        print("[突破] 自动突破未在运行")
        return
    end
    
    CultState.isAutoBreakthrough = false
    
    if CultState.breakthroughConnection then
        CultState.breakthroughConnection:Disconnect()
        CultState.breakthroughConnection = nil
    end
    
    print("[突破] 自动突破已停止")
end

local function breakthroughOnce()
    if not CultState.isCultivating then
        print("[突破] 未在修炼状态，无法突破")
        return false
    end
    
    BreakthroughEvent:FireServer()
    print("[突破] 单次突破请求已发送")
    return true
end

-- ===================== 炼药功能 =====================
local function startCraftPills(pillType, count)
    if PillState.isCrafting then
        print("[炼药] 炼药已在运行中")
        return false
    end
    
    if not pillType or pillType == "" then
        print("[炼药] 请选择丹药类型")
        return false
    end
    
    -- 检查炼药事件是否存在
    if not CraftPillEvent or not CraftPillEvent.FireServer then
        print("[炼药] 错误: 炼药事件未找到或无效")
        return false
    end
    
    count = math.max(1, tonumber(count) or 1)
    
    print(string.format("[炼药] 开始炼制 %s x%d (间隔: %d秒)", pillType, count, PillState.craftInterval))
    
    PillState.isCrafting = true
    PillState.currentPillType = pillType
    PillState.craftCount = count
    
    task.spawn(function()
        local crafted = 0
        
        while PillState.isCrafting and crafted < count do
            -- 再次安全检查
            if not CraftPillEvent or not CraftPillEvent.FireServer then
                print("[炼药] 错误: 炼药事件丢失，停止炼药")
                break
            end
            
            -- 使用pcall安全调用
            local success, err = pcall(function()
                CraftPillEvent:FireServer(pillType)
            end)
            
            if not success then
                print("[炼药] 触发远程炼药事件失败: " .. tostring(err))
                break
            end
            
            crafted = crafted + 1
            
            print(string.format("[炼药] 触发远程炼药事件 (%d/%d) - 时间: %s", 
                crafted, count, os.date("%H:%M:%S")))
            
            -- 只有不是最后一次时才等待
            if crafted < count then
                -- 使用真正的等待时间
                local waitStart = tick()
                while PillState.isCrafting and tick() - waitStart < PillState.craftInterval do
                    task.wait(0.1) -- 每0.1秒检查一次，避免长时间阻塞
                end
            end
        end
        
        -- 炼药完成后重置状态
        if PillState.isCrafting then
            PillState.isCrafting = false
            print(string.format("[炼药] 炼药完成，共炼制 %d 次", crafted))
        end
    end)
    
    return true
end

local function stopCraftPills()
    if not PillState.isCrafting then
        print("[炼药] 炼药未在运行")
        return false
    end
    
    PillState.isCrafting = false
    
    print("[炼药] 炼药已停止")
    return true
end

local function craftSinglePill(pillType)
    if not pillType or pillType == "" then
        print("[炼药] 请选择丹药类型")
        return false
    end
    
    -- 检查炼药事件是否存在
    if not CraftPillEvent or not CraftPillEvent.FireServer then
        print("[炼药] 错误: 炼药事件未找到或无效")
        return false
    end
    
    -- 使用pcall安全调用
    local success, err = pcall(function()
        CraftPillEvent:FireServer(pillType)
    end)
    
    if success then
        print(string.format("[炼药] 触发单次炼药事件 - 时间: %s", os.date("%H:%M:%S")))
    else
        print("[炼药] 触发单次炼药事件失败: " .. tostring(err))
    end
    
    return success
end

-- ===================== 修复一键加速：实时监控新草药 =====================
local function modifySingleHerbPickTime(herb)
    if not herb then return false end
    
    -- 检查是否已经修改过
    if HerbState.modifiedHerbs[herb] then
        return false
    end
    
    local success = false
    
    -- 递归查找ProximityPrompt
    local function findAndChangePrompts(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("ProximityPrompt") then
                -- 把按住时间改成0，这样点一下就采到了
                child.HoldDuration = 0
                
                -- 有些草药可能还有Data子项，也一起改了
                if child:FindFirstChild("Data") then
                    local data = child.Data
                    local holdTime = data:FindFirstChild("HoldDuration")
                    if holdTime then
                        holdTime.Value = 0
                    end
                end
                
                success = true
            else
                -- 继续往子对象里找
                findAndChangePrompts(child)
            end
        end
    end
    
    findAndChangePrompts(herb)
    
    if success then
        HerbState.modifiedHerbs[herb] = true
    end
    
    return success
end

local function setupQuickPickListener()
    if HerbState.quickPickConnection then
        HerbState.quickPickConnection:Disconnect()
        HerbState.quickPickConnection = nil
    end
    
    if not HerbState.quickPickEnabled then
        return
    end
    
    print("[一键加速] 设置草药监控器")
    
    -- 监听草药文件夹
    local herbsFolder = Workspace:FindFirstChild(CONFIG.HERBS_FOLDER_NAME)
    if herbsFolder then
        -- 立即修改所有现有草药
        print("[一键加速] 开始修改所有现有草药...")
        for _, herb in ipairs(herbsFolder:GetChildren()) do
            if herb and herb.Parent then
                modifySingleHerbPickTime(herb)
                print("[一键加速] 修改草药: " .. herb.Name)
            end
        end
        print("[一键加速] 所有现有草药已修改完成")
        
        -- 监听新生成的草药
        HerbState.quickPickConnection = herbsFolder.ChildAdded:Connect(function(child)
            if child and child.Parent then
                task.wait(0.5) -- 等待0.5秒让草药完全生成
                modifySingleHerbPickTime(child)
                print("[一键加速] 新草药已修改: " .. child.Name)
            end
        end)
    else
        print("[一键加速] 警告: 未找到草药文件夹")
    end
end

local function toggleQuickPick()
    HerbState.quickPickEnabled = not HerbState.quickPickEnabled
    
    if HerbState.quickPickEnabled then
        print("[一键加速] 开启一键加速")
        -- 设置监听器
        setupQuickPickListener()
        -- 再次确保修改所有现有草药
        local herbsFolder = Workspace:FindFirstChild(CONFIG.HERBS_FOLDER_NAME)
        if herbsFolder then
            for _, herb in ipairs(herbsFolder:GetChildren()) do
                modifySingleHerbPickTime(herb)
            end
        end
    else
        print("[一键加速] 关闭一键加速")
        -- 清除修改记录和监听器
        HerbState.modifiedHerbs = {}
        if HerbState.quickPickConnection then
            HerbState.quickPickConnection:Disconnect()
            HerbState.quickPickConnection = nil
        end
    end
    
    return HerbState.quickPickEnabled
end

-- ===================== 修复功法自动收集：使用 fireproximityprompt =====================
local function autoCollectNearestAura()
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local playerPos = humanoidRootPart.Position
    local nearestPrompt = nil
    local nearestDistance = math.huge
    
    -- 递归查找ProximityPrompt
    local function findProximityPrompt(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child and child.Parent then
                if child:IsA("ProximityPrompt") then
                    -- 获取功法位置
                    local auraPos = nil
                    
                    -- 处理BasePart类型的对象
                    if obj:IsA("BasePart") then
                        auraPos = obj.Position
                    -- 处理Model类型的对象
                    elseif obj:IsA("Model") then
                        -- 首先尝试PrimaryPart
                        if obj.PrimaryPart and obj.PrimaryPart:IsA("BasePart") then
                            auraPos = obj.PrimaryPart.Position
                        else
                            -- 查找任何BasePart子对象
                            for _, part in ipairs(obj:GetChildren()) do
                                if part and part:IsA("BasePart") then
                                    auraPos = part.Position
                                    break
                                end
                            end
                        end
                    end
                    
                    -- 如果找到了有效位置，计算距离
                    if auraPos then
                        local distance = (auraPos - playerPos).Magnitude
                        -- 如果在15个单位距离内（与草药相同）
                        if distance < AuraAutoCollectState.maxDistance and distance < nearestDistance then
                            nearestDistance = distance
                            nearestPrompt = child -- 保存ProximityPrompt对象
                        end
                    end
                    return
                else
                    -- 递归查找子对象
                    findProximityPrompt(child)
                end
            end
        end
    end
    
    -- 扫描Workspace中的所有对象
    local function scanWorkspaceForAuras()
        for _, obj in ipairs(Workspace:GetChildren()) do
            if obj and obj:IsA("Model") and obj.Parent == Workspace then
                for _, child in ipairs(obj:GetChildren()) do
                    if child:IsA("ProximityPrompt") then
                        findProximityPrompt(obj)
                        return
                    end
                end
            end
        end
    end
    -- 安全扫描
    local success, errorMsg = pcall(function()
        scanWorkspaceForAuras()
    end)
    
    if not success then
        print("[功法自动收集] 扫描功法时出错: " .. tostring(errorMsg))
        return
    end
    
    -- 如果找到最近的功法ProximityPrompt，就触发采摘
    if nearestPrompt then
        -- 使用 fireproximityprompt 函数替代 Trigger 方法
        local success, err = pcall(function()
            -- 正确的用法：fireproximityprompt(proximityPrompt, player)
            fireproximityprompt(nearestPrompt, player)
        end)
        
        if success then
            local promptParent = nearestPrompt.Parent
            local name = promptParent and promptParent.Name or "未知功法"
            print(string.format("[功法自动收集] 触发功法: %s (距离: %.1f米)", name, nearestDistance))
        else
            print("[功法自动收集] 触发功法失败: " .. tostring(err))
        end
    end
end

-- ===================== 修复自动采摘功能：同样使用 fireproximityprompt =====================
local function autoHarvestNearestHerb()
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local herbsFolder = Workspace:FindFirstChild("Herbs")
    if not herbsFolder then return end
    
    local playerPos = humanoidRootPart.Position
    local nearestHerb = nil
    local nearestDistance = math.huge
    
    -- 找最近的草药
    for _, herb in ipairs(herbsFolder:GetChildren()) do
        -- 递归找ProximityPrompt
        local function findProximityPrompt(obj)
            for _, child in ipairs(obj:GetChildren()) do
                if child:IsA("ProximityPrompt") then
                    -- 修复：安全地获取草药位置
                    local herbPos
                    if obj:IsA("BasePart") then
                        herbPos = obj.Position
                    elseif obj:IsA("Model") then
                        -- 对于Model，尝试获取PrimaryPart或任何BasePart
                        if obj.PrimaryPart and obj.PrimaryPart:IsA("BasePart") then
                            herbPos = obj.PrimaryPart.Position
                        else
                            -- 查找任何BasePart
                            for _, part in ipairs(obj:GetChildren()) do
                                if part:IsA("BasePart") then
                                    herbPos = part.Position
                                    break
                                end
                            end
                        end
                    end
                    
                    if herbPos then
                        local distance = (herbPos - playerPos).Magnitude
                        -- 如果在15个单位距离内
                        if distance < 15 and distance < nearestDistance then
                            nearestDistance = distance
                            nearestHerb = child
                        end
                    end
                    return
                else
                    findProximityPrompt(child)
                end
            end
        end
        
        findProximityPrompt(herb)
    end
    
    -- 如果找到最近的草药，就触发采摘
    if nearestHerb then
        -- 使用 fireproximityprompt 函数替代 Trigger 方法
        local success, err = pcall(function()
            fireproximityprompt(nearestHerb, player)
        end)
        
        if success then
            print(string.format("[自动采摘] 触发草药: %s (距离: %.1f米)", 
                nearestHerb.Parent.Name, nearestDistance))
        else
            print("[自动采摘] 触发草药失败: " .. tostring(err))
        end
    end
end

-- ===================== 开关功法自动收集 =====================
local function toggleAuraAutoCollect()
    AuraAutoCollectState.enabled = not AuraAutoCollectState.enabled
    
    if AuraAutoCollectState.enabled then
        print(string.format("[功法自动收集] 开启功法自动收集 (%.1f秒间隔, 距离: %d米)", 
            AuraAutoCollectState.collectInterval, AuraAutoCollectState.maxDistance))
        
        -- 创建一个新的连接器
        if AuraAutoCollectState.connection then
            AuraAutoCollectState.connection:Disconnect()
            AuraAutoCollectState.connection = nil
        end
        
        AuraAutoCollectState.connection = RunService.Heartbeat:Connect(function()
            autoCollectNearestAura()
            task.wait(AuraAutoCollectState.collectInterval)
        end)
    else
        print("[功法自动收集] 关闭功法自动收集")
        if AuraAutoCollectState.connection then
            AuraAutoCollectState.connection:Disconnect()
            AuraAutoCollectState.connection = nil
        end
    end
    
    return AuraAutoCollectState.enabled
end

-- ===================== 开关自动采摘 =====================
local function toggleAutoHarvest()
    HerbState.autoHarvestEnabled = not HerbState.autoHarvestEnabled
    
    if HerbState.autoHarvestEnabled then
        print("[自动采摘] 开启自动采摘 (0.1秒间隔)")
        -- 每0.1秒检查一次附近的草药
        HerbState.autoHarvestConnection = RunService.Heartbeat:Connect(function()
            autoHarvestNearestHerb()
            task.wait(0.1)
        end)
    else
        print("[自动采摘] 关闭自动采摘")
        if HerbState.autoHarvestConnection then
            HerbState.autoHarvestConnection:Disconnect()
            HerbState.autoHarvestConnection = nil
        end
    end
    
    return HerbState.autoHarvestEnabled
end

-- ===================== 移动设备适配 =====================
local MobileToggleButton = nil
local MobileToggleGUI = nil

local function createMobileToggle()
    -- 清理旧按钮
    if CoreGui:FindFirstChild("HerbMobileToggle") then
        CoreGui.HerbMobileToggle:Destroy()
    end
    
    -- 只在移动设备上显示按钮
    if UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled then
        print("[移动端] 检测到键盘设备，隐藏移动端按钮")
        return
    end
    
    print("[移动端] 创建移动端切换按钮")
    
    local mobileToggleGUI = Instance.new("ScreenGui")
    mobileToggleGUI.Name = "HerbMobileToggle"
    mobileToggleGUI.Parent = CoreGui
    mobileToggleGUI.ResetOnSpawn = false
    mobileToggleGUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    mobileToggleGUI.DisplayOrder = 100
    
    local toggleButton = Instance.new("TextButton")
    toggleButton.Name = "ToggleButton"
    toggleButton.Parent = mobileToggleGUI
    toggleButton.BackgroundColor3 = Color3.fromRGB(40, 60, 40)
    toggleButton.BorderColor3 = Color3.fromRGB(29, 29, 35)
    toggleButton.Position = UDim2.new(0.005, 0, 0.4, 0)
    toggleButton.Size = UDim2.new(0, 80, 0, 36)
    toggleButton.Font = Enum.Font.SourceSansBold
    toggleButton.Text = "打开界面"
    toggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleButton.TextSize = 14
    toggleButton.Active = true
    toggleButton.Draggable = true
    toggleButton.Visible = true
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 5)
    buttonCorner.Parent = toggleButton
    
    MobileToggleButton = toggleButton
    MobileToggleGUI = mobileToggleGUI
    
    return mobileToggleGUI
end

-- ===================== 修复功法扫描函数 =====================
local function scanAuras()
    print("[功法扫描] ======= 开始扫描功法 =======")
    print("[功法扫描] 搜索方法: Workspace第一层Model，检查ProximityPrompt")
    
    local validAuras = {}
    
    -- 使用pcall安全执行
    local success, errorMsg = pcall(function()
        -- 只搜索Workspace的第一层对象
        for _, child in pairs(Workspace:GetChildren()) do
            if child and child:IsA("Model") and child.Parent == Workspace then
                -- 检查Model中是否有ProximityPrompt
                local hasProximityPrompt = false
                
                -- 搜索Model的直接子对象
                for _, descendant in pairs(child:GetChildren()) do
                    if descendant and descendant:IsA("ProximityPrompt") then
                        hasProximityPrompt = true
                        break
                    end
                end
                
                if hasProximityPrompt then
                    table.insert(validAuras, child)
                    print(string.format("[功法扫描] 找到功法: %s (包含ProximityPrompt)", child.Name))
                end
            end
        end
    end)
    
    if not success then
        warn("[功法扫描] 扫描过程中发生错误: " .. tostring(errorMsg))
    end
    
    print(string.format("[功法扫描] 扫描完成，找到 %d 个有效功法", #validAuras))
    
    -- 确保总是返回一个表，即使为空
    return validAuras
end

-- ===================== 草药采摘功能 =====================
local function StopAllMovement()
    if HerbState.FlightBodyVelocity then
        HerbState.FlightBodyVelocity:Destroy()
        HerbState.FlightBodyVelocity = nil
    end
    if HerbState.FlightBodyGyro then
        HerbState.FlightBodyGyro:Destroy()
        HerbState.FlightBodyGyro = nil
    end
    
    if humanoid and humanoid.Parent then
        humanoid.PlatformStand = false
    end
    
    if workspace then
        workspace.Gravity = HerbState.OriginalGravity
    end
    
    if humanoidRootPart and humanoidRootPart.Parent then
        humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    end
    
    HerbState.IsFlying = false
    if HerbState.FlightConnection then
        HerbState.FlightConnection:Disconnect()
        HerbState.FlightConnection = nil
    end
end

local function enableFlight()
    if HerbState.IsFlying or not humanoid or not humanoidRootPart then 
        print("[飞行] 飞行已启用或角色组件不存在")
        return 
    end
    
    -- 确保之前的飞行组件已清理
    StopAllMovement()
    
    print("[飞行] 启用飞行模式...")
    
    -- 设置角色状态
    humanoid.PlatformStand = true
    workspace.Gravity = HerbState.OriginalGravity * 0.1
    
    -- 创建BodyVelocity
    local bodyVelocity = Instance.new("BodyVelocity")
    bodyVelocity.Name = "FlightVelocity"
    bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)  -- 增加力度
    bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    bodyVelocity.P = 5000  -- 增加P值以获得更快的响应
    bodyVelocity.Parent = humanoidRootPart
    HerbState.FlightBodyVelocity = bodyVelocity
    
    -- 创建BodyGyro
    local bodyGyro = Instance.new("BodyGyro")
    bodyGyro.Name = "FlightGyro"
    bodyGyro.MaxTorque = Vector3.new(100000, 100000, 100000)
    bodyGyro.CFrame = humanoidRootPart.CFrame
    bodyGyro.P = 3000
    bodyGyro.D = 1000
    bodyGyro.Parent = humanoidRootPart
    HerbState.FlightBodyGyro = bodyGyro
    
    -- 创建飞行连接器
    local lastUpdate = tick()
    HerbState.FlightConnection = RunService.Heartbeat:Connect(function()
        if not HerbState.IsFlying or not humanoidRootPart or not humanoidRootPart.Parent then
            StopAllMovement()
            return
        end
        
        local currentTime = tick()
        local deltaTime = currentTime - lastUpdate
        lastUpdate = currentTime
        
        -- 稳定飞行高度 - 使用CONFIG.FLY_HEIGHT而不是更高的值
        local targetY = CONFIG.FLY_HEIGHT  -- 750米
        local currentY = humanoidRootPart.Position.Y
        local heightDifference = targetY - currentY
        
        -- 只有当BodyVelocity存在时才更新
        if HerbState.FlightBodyVelocity and HerbState.FlightBodyVelocity.Parent then
            local yVelocity = 0
            if math.abs(heightDifference) > 10 then
                yVelocity = heightDifference * 5
            elseif math.abs(heightDifference) > 1 then
                yVelocity = heightDifference * 10
            end
            
            -- 保持当前水平速度，只调整垂直速度
            HerbState.FlightBodyVelocity.Velocity = Vector3.new(
                HerbState.FlightBodyVelocity.Velocity.X,
                yVelocity,
                HerbState.FlightBodyVelocity.Velocity.Z
            )
        end
        
        -- 更新陀螺仪
        if HerbState.FlightBodyGyro then
            HerbState.FlightBodyGyro.CFrame = humanoidRootPart.CFrame
        end
    end)
    
    HerbState.IsFlying = true
    -- print("[飞行] 飞行模式已启用，高度: " .. CONFIG.FLY_HEIGHT .. "米")
end

-- ===================== 修复：功法位置获取优化 =====================
local function getHerbPosition(herb)
    if not herb or not herb.Parent then
        warn("[坐标] 对象不存在或已销毁")
        return Vector3.new(0, 0, 0)
    end
    
    -- 使用 pcall 安全执行所有操作
    local success, position = pcall(function()
        -- 方法1: 对于 BasePart，直接返回 Position
        if herb:IsA("BasePart") then
            return herb.Position
        end
        
        -- 方法2: 对于 Model，尝试多种方式
        if herb:IsA("Model") then
            -- 2.1 检查 PrimaryPart
            if herb.PrimaryPart and herb.PrimaryPart:IsA("BasePart") then
                return herb.PrimaryPart.Position
            end
            
            -- 2.2 尝试 GetPivot() 方法
            local success2, pivotResult = pcall(function()
                return herb:GetPivot()
            end)
            
            if success2 and pivotResult then
                if typeof(pivotResult) == "CFrame" then
                    return pivotResult.Position
                elseif typeof(pivotResult) == "Vector3" then
                    return pivotResult
                end
            end
            
            -- 2.5 查找任何 BasePart 子对象
            for _, child in ipairs(herb:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        
        -- 如果所有方法都失败，返回默认位置
        return Vector3.new(0, 0, 0)
    end)
    
    if success and position then
        return position
    else
        warn("[坐标] 获取对象位置时发生错误: " .. (herb and herb.Name or "未知对象") .. " - " .. tostring(position))
        return Vector3.new(0, 0, 0)
    end
end

local function getAuraPosition(auraModel)
    if not auraModel or not auraModel.Parent then
        warn("[功法坐标] 功法Model不存在或已销毁")
        return Vector3.new(0, 0, 0)
    end
    
    local success, result = pcall(function()
        -- 首先尝试从Model本身获取位置
        if auraModel:IsA("Model") then
            -- 尝试使用GetPivot方法
            local success2, pivotResult = pcall(function()
                return auraModel:GetPivot()
            end)
            
            if success2 and pivotResult and typeof(pivotResult) == "CFrame" then
                return pivotResult.Position
            end
            
            -- 尝试PrimaryPart
            if auraModel.PrimaryPart and auraModel.PrimaryPart:IsA("BasePart") then
                return auraModel.PrimaryPart.Position
            end
            
            -- 查找任何BasePart子对象
            for _, child in ipairs(auraModel:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        
        -- 如果常规方法失败，尝试查找ProximityPrompt并获取其父级坐标
        for _, child in ipairs(auraModel:GetDescendants()) do
            if child:IsA("ProximityPrompt") then
                local parent = child.Parent
                if parent then
                    if parent:IsA("BasePart") then
                        return parent.Position
                    elseif parent:IsA("Model") then
                        local parentPos = parent.PrimaryPart and parent.PrimaryPart.Position
                        if parentPos then
                            return parentPos
                        end
                    end
                end
                break
            end
        end
        
        return Vector3.new(0, 0, 0)
    end)
    
    if success and result then
        return result
    else
        warn("[功法坐标] 获取功法位置时发生错误")
        return Vector3.new(0, 0, 0)
    end
end

local function getHerbAge(herb)
    -- 这个函数只用于草药，功法不需要年龄
    if not herb or not herb.Parent then
        return 0
    end
    
    if HerbState.herbAgeCache[herb] ~= nil then
        return HerbState.herbAgeCache[herb]
    end
    
    local age = 0
    
    -- 只处理草药，功法不需要年龄
    -- 检查是否是功法（包含ProximityPrompt的Model）
    local isAura = false
    if herb:IsA("Model") then
        for _, child in ipairs(herb:GetChildren()) do
            if child:IsA("ProximityPrompt") then
                isAura = true
                break
            end
        end
    end
    
    if isAura then
        -- 功法不需要年龄，直接返回0
        HerbState.herbAgeCache[herb] = 0
        return 0
    end
    
    -- 以下是草药的年龄获取逻辑
    if herb:IsA("Model") then
        -- 查找Model中的Age属性或AgeValue
        local success, result = pcall(function()
            return herb:GetAttribute("Age")
        end)
        
        if success and result ~= nil then
            age = tonumber(result) or 0
        else
            -- 查找Model中的子对象
            if herb:FindFirstChild("AgeValue") and herb.AgeValue:IsA("ValueBase") then
                age = tonumber(herb.AgeValue.Value) or 0
            elseif herb:FindFirstChild("Age") then
                local ageObj = herb:FindFirstChild("Age")
                if ageObj:IsA("ValueBase") then
                    age = tonumber(ageObj.Value) or 0
                end
            end
        end
    else
        -- 普通Part/MeshPart的处理
        local success, result = pcall(function()
            return herb:GetAttribute("Age")
        end)
        
        if success and result ~= nil then
            age = tonumber(result) or 0
        else
            if herb:FindFirstChild("AgeValue") then
                age = tonumber(herb.AgeValue.Value) or 0
            elseif herb:FindFirstChild("Age") then
                age = tonumber(herb.Age) or 0
            end
        end
    end
    
    HerbState.herbAgeCache[herb] = age
    return age
end

local function getHerbPriority(herbName)
    if not herbName or #HerbState.priorityHerbs == 0 then
        return nil
    end
    
    for _, priorityHerb in ipairs(HerbState.priorityHerbs) do
        if priorityHerb.name == herbName then
            return priorityHerb.priority
        end
    end
    
    return nil
end

local function scanHerbs()
    local herbsFolder = Workspace:FindFirstChild(CONFIG.HERBS_FOLDER_NAME)
    if not herbsFolder then 
        warn("[扫描] 未找到草药文件夹：" .. CONFIG.HERBS_FOLDER_NAME)
        
        -- 尝试其他名称
        for _, child in ipairs(Workspace:GetChildren()) do
            if child.Name:match("Herb") or child.Name:match("草药") then
                herbsFolder = child
                break
            end
        end
        
        if not herbsFolder then
            return {} 
        else
            print("[扫描] 找到替代草药文件夹：" .. herbsFolder.Name)
        end
    end

    local validHerbs = {}
    local currentTime = tick()
    
    -- 清理过期的超时记录
    for herb, timeoutTime in pairs(HerbState.timeoutHerbs) do
        if currentTime - timeoutTime > CONFIG.TIMEOUT_COOLDOWN then
            HerbState.timeoutHerbs[herb] = nil
        end
    end
    
    -- 扫描所有草药对象
    for _, item in ipairs(herbsFolder:GetChildren()) do
        if not item or not item.Parent then
            continue
        end
        
        -- 检查是否是黑名单草药
        local isBlacklisted = false
        for _, blacklistName in ipairs(CONFIG.BLACKLIST_HERBS) do
            if item.Name == blacklistName or item.Name:match(blacklistName) then
                isBlacklisted = true
                print(string.format("[扫描] 跳过黑名单草药: %s", item.Name))
                break
            end
        end
        
        if isBlacklisted then
            continue
        end
        
        -- 如果开启了一键加速，修改采摘时间
        if HerbState.quickPickEnabled then
            modifySingleHerbPickTime(item)
        end
        
        -- 检查是否已采集
        local isCollected = false
        for collectedHerb, _ in pairs(HerbState.collectedHerbs) do
            if collectedHerb and collectedHerb == item then
                isCollected = true
                break
            end
        end
        
        -- 检查是否超时
        local isTimedOut = false
        for timeoutHerb, timeoutTime in pairs(HerbState.timeoutHerbs) do
            if timeoutHerb and timeoutHerb == item then
                if currentTime - timeoutTime < CONFIG.TIMEOUT_COOLDOWN then
                    isTimedOut = true
                end
                break
            end
        end
        
        local isCurrentTarget = (HerbState.currentHerb and HerbState.currentHerb == item)
        
        -- 支持多种类型的草药对象
        local isValidType = item:IsA("MeshPart") or item:IsA("Part") or item:IsA("Model")
        
        if isValidType and not isCollected and not isTimedOut and (not isCurrentTarget or not item.Parent) then
            -- 如果是Model，检查其中是否有可交互的部分
            if item:IsA("Model") then
                -- 检查Model是否有PrimaryPart或者任何MeshPart/Part
                if item.PrimaryPart or #item:GetChildren() > 0 then
                    table.insert(validHerbs, item)
                end
            else
                table.insert(validHerbs, item)
            end
        end
    end
    
    print(string.format("[扫描] 找到有效草药数量：%d", #validHerbs))
    
    return validHerbs
end

local function filterHerbsByPriority(herbs)
    if #HerbState.priorityHerbs == 0 then
        return herbs, {}, false
    end
    
    local priorityHerbs = {}
    local nonPriorityHerbs = {}
    local priorityMap = {}
    
    for _, priorityHerb in ipairs(HerbState.priorityHerbs) do
        priorityMap[priorityHerb.name] = priorityHerb.priority
    end
    
    for _, herb in ipairs(herbs) do
        if herb and herb.Parent then
            local priority = priorityMap[herb.Name]
            if priority then
                table.insert(priorityHerbs, {herb = herb, priority = priority})
            else
                table.insert(nonPriorityHerbs, herb)
            end
        end
    end
    
    -- 将priorityHerbs转换为带有priority信息的列表
    local formattedPriorityHerbs = {}
    for _, info in ipairs(priorityHerbs) do
        table.insert(formattedPriorityHerbs, info)
    end
    
    return formattedPriorityHerbs, nonPriorityHerbs, true
end

local function findBestTarget()
    -- 根据目标模式决定寻找目标
    if HerbState.targetMode == "aura" or HerbState.targetMode == "both" then
        -- 优先查找功法
        local allAuras = scanAuras()
        if #allAuras > 0 then
            print("[寻找] 找到功法，优先采集功法")
            
            -- 按距离排序，选择最近的功法
            local closestAura = nil
            local closestDistance = math.huge
            local playerPos = humanoidRootPart and humanoidRootPart.Position or Vector3.new(0, 0, 0)
            
            for _, aura in ipairs(allAuras) do
                if aura and aura.Parent then
                    local auraPos = getAuraPosition(aura)
                    if auraPos and auraPos ~= Vector3.new(0, 0, 0) then  -- 确保获取到了有效位置
                        local distance = (auraPos - playerPos).Magnitude
                        
                        if distance < closestDistance then
                            closestDistance = distance
                            closestAura = aura
                        end
                    end
                end
            end
            
            if closestAura then
                AuraState.currentAura = closestAura
                HerbState.currentHerb = nil
                print(string.format("[寻找] 选择功法: %s (距离: %.1f米)", closestAura.Name, closestDistance))
                return closestAura, true -- 第二个参数true表示这是功法
            else
                print("[寻找] 虽然扫描到功法，但所有功法都无法访问")
            end
        else
            print("[寻找] 未找到任何功法")
        end
    end
    
    -- 如果没有功法或者目标模式不是功法优先，则查找草药
    if HerbState.targetMode == "herb" or HerbState.targetMode == "both" then
        AuraState.currentAura = nil
        local allHerbs = scanHerbs()
        if #allHerbs == 0 then 
            print("[寻找] 未找到任何有效草药")
            HerbState.failCount = HerbState.failCount + 1
            
            if HerbState.failCount >= 3 then
                print("[寻找] 连续3次未找到目标，重置扫描状态")
                HerbState.collectedHerbs = {}
                HerbState.timeoutHerbs = {}
                HerbState.herbAgeCache = {}
                HerbState.failCount = 0
                
                allHerbs = scanHerbs()
                if #allHerbs == 0 then
                    print("[寻找] 重置后仍未找到目标")
                    return nil, false
                end
            else
                return nil, false
            end
        else
            HerbState.failCount = 0
        end

        local priorityHerbs, nonPriorityHerbs, hasPriority = filterHerbsByPriority(allHerbs)
        
        -- 如果有优先级草药，按年份从大到小排序，年份相同按距离从小到大排序
        if hasPriority and #priorityHerbs > 0 then
            print(string.format("[优先级] 用户选择了 %d 种优先级草药", #HerbState.priorityHerbs))
            
            local allPriorityHerbs = {}
            for _, priorityInfo in ipairs(priorityHerbs) do
                local herb = priorityInfo.herb
                local priority = priorityInfo.priority
                
                if herb and herb.Parent then
                    local age = getHerbAge(herb)
                    local herbPos = getHerbPosition(herb)
                    local distance = (herbPos - humanoidRootPart.Position).Magnitude
                    
                    table.insert(allPriorityHerbs, {
                        herb = herb,
                        priority = priority,
                        age = age,
                        distance = distance
                    })
                end
            end
            
            if #allPriorityHerbs > 0 then
                table.sort(allPriorityHerbs, function(a, b)
                    if a.age ~= b.age then
                        return a.age > b.age
                    else
                        return a.distance < b.distance
                    end
                end)
                
                local bestHerb = allPriorityHerbs[1].herb
                local bestAge = allPriorityHerbs[1].age
                local bestDistance = allPriorityHerbs[1].distance
                
                print(string.format("[优先级] 选择年份最大草药: %s (年份: %d, 距离: %.1f米)", 
                    bestHerb.Name, bestAge, bestDistance))
                
                return bestHerb, false
            else
                print("[优先级] 没有找到有效的优先级草药，将在所有草药中寻找")
                hasPriority = false
            end
        else
            print("[优先级] 未选择优先级草药，将选择年份最大的草药")
        end
        
        -- 如果没有优先级草药或优先级草药都无效，则从所有草药中选择年份最大的
        local herbsToCheck = nonPriorityHerbs
        if not hasPriority then
            herbsToCheck = allHerbs
        end
        
        if #herbsToCheck > 0 then
            print(string.format("[寻找] 在 %d 个草药中寻找年份最大的", #herbsToCheck))
            
            local herbInfoList = {}
            local playerPos = humanoidRootPart.Position
            
            for _, herb in ipairs(herbsToCheck) do
                if herb and herb.Parent then
                    local age = getHerbAge(herb)
                    local herbPos = getHerbPosition(herb)
                    local distance = (herbPos - playerPos).Magnitude
                    
                    table.insert(herbInfoList, {
                        herb = herb,
                        age = age,
                        distance = distance
                    })
                end
            end
            
            if #herbInfoList == 0 then
                print("[寻找] 没有可用的草药")
                return nil, false
            end
            
            table.sort(herbInfoList, function(a, b)
                if a.age ~= b.age then
                    return a.age > b.age
                else
                    return a.distance < b.distance
                end
            end)
            
            local bestHerb = herbInfoList[1].herb
            local bestAge = herbInfoList[1].age
            local bestDistance = herbInfoList[1].distance
            
            print(string.format("[寻找] 选择年份最大草药: %s (年份: %d, 距离: %.1f米)", 
                bestHerb.Name, bestAge, bestDistance))
            
            return bestHerb, false
        end
    end
    
    print("[寻找] 没有可用的目标")
    return nil, false
end

local function flyToTarget(target, isAura)
    if not target or not HerbState.IsFlying then 
        warn("[飞行] 飞行模式未启用或目标不存在")
        return false 
    end
    
    -- 确保飞行组件存在
    if not HerbState.FlightBodyVelocity or not HerbState.FlightBodyVelocity.Parent then
        print("[飞行] 飞行组件不存在，重新创建")
        enableFlight()
        task.wait(0.5) -- 等待飞行组件初始化
    end

    local targetType = isAura and "功法" or "草药"
    -- print(string.format("[飞行] 开始前往%s：%s", targetType, target.Name))
    local startTime = tick()
    
    -- 重置飞行组件速度
    if HerbState.FlightBodyVelocity then
        HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    end

    -- 飞行到达调试计数器
    local checkCount = 0
    local lastDistance = math.huge
    local stagnantCount = 0  -- 停滞计数器

    while HerbState.isRunning and target and target.Parent do
        -- 安全检查
        if not HerbState.FlightBodyVelocity or not HerbState.FlightBodyVelocity.Parent then
            warn("[飞行] 飞行组件已销毁，重新创建")
            enableFlight()
            task.wait(0.5)
        end
        
        -- 超时检查
        if tick() - startTime > CONFIG.MOVE_TIMEOUT then
            warn("[飞行] 前往" .. targetType .. "超时（超过" .. CONFIG.MOVE_TIMEOUT .. "秒）")
            if HerbState.FlightBodyVelocity then
                HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            HerbState.timeoutHerbs[target] = tick()
            HerbState.currentTimeoutCount = HerbState.currentTimeoutCount + 1
            print("[飞行] 已将" .. targetType .. " " .. target.Name .. " 加入超时列表")
            return false
        end

        -- 安全地获取目标位置
        local targetPos = nil
        local success, posResult = pcall(function()
            if isAura then
                return getAuraPosition(target)
            else
                return getHerbPosition(target)
            end
        end)
        
        if success and posResult then
            targetPos = posResult
        else
            warn("[飞行] 无法获取" .. targetType .. "位置: " .. target.Name)
            HerbState.timeoutHerbs[target] = tick()
            HerbState.currentTimeoutCount = HerbState.currentTimeoutCount + 1
            return false
        end
        
        -- 关键修复：对于功法，使用与草药相同的飞行高度（而不是更高的高度）
        local flyHeight = CONFIG.FLY_HEIGHT  -- 统一使用750米飞行高度
        local targetFlyPos = Vector3.new(targetPos.X, flyHeight, targetPos.Z)
        local currentPos = humanoidRootPart.Position
        
        -- 计算水平距离（忽略垂直高度）
        local horizontalDistance = Vector3.new(targetPos.X, 0, targetPos.Z).Magnitude - Vector3.new(currentPos.X, 0, currentPos.Z).Magnitude
        local actualHorizontalDistance = (Vector3.new(targetPos.X, 0, targetPos.Z) - Vector3.new(currentPos.X, 0, currentPos.Z)).Magnitude
        local verticalDistance = math.abs(flyHeight - currentPos.Y)
        local totalDistance = (targetFlyPos - currentPos).Magnitude
        
        -- 每10次检查打印一次距离信息
        --checkCount = checkCount + 1
        --if checkCount % 10 == 0 then
        --    print(string.format("[飞行] 水平距离: %.2f米，垂直距离: %.2f米，总距离: %.2f米", 
        --        actualHorizontalDistance, verticalDistance, totalDistance))
        --end

        -- 关键修复：到达判断 - 当水平距离小于阈值时，就认为到达
        if actualHorizontalDistance <= CONFIG.MOVE_DISTANCE_THRESHOLD then
            if HerbState.FlightBodyVelocity then
                HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            end
            HerbState.currentTimeoutCount = 0
            print(string.format("[飞行] 到达%s %s 正上方（水平距离：%.1f米，垂直距离：%.1f米）", 
                targetType, target.Name, actualHorizontalDistance, verticalDistance))
            return true
        end
        
        -- 检查距离是否在减少
        if actualHorizontalDistance >= lastDistance - 0.1 then
            stagnantCount = stagnantCount + 1
        else
            stagnantCount = 0
        end
        
        lastDistance = actualHorizontalDistance
        
        -- 如果停滞超过20次，尝试重新计算方向或强制到达
        if stagnantCount > 20 then
            print(string.format("[飞行] 飞行停滞，尝试调整 (停滞次数: %d)", stagnantCount))
            
            -- 关键修复：如果水平距离已经很近（小于50米），直接认为到达
            if actualHorizontalDistance < 50 then  
                if HerbState.FlightBodyVelocity then
                    HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                HerbState.currentTimeoutCount = 0
                print(string.format("[飞行] 飞行停滞但水平距离较近(%.1f米)，认为已到达", actualHorizontalDistance))
                return true
            end
            
            -- 重置停滞计数器
            stagnantCount = 0
        end

        -- 关键修复：确保飞行速度正确应用
        local direction = (targetFlyPos - currentPos).Unit
        
        -- 调整垂直速度
        local verticalSpeed = 0
        local heightDiff = targetFlyPos.Y - currentPos.Y
        
        if math.abs(heightDiff) > 10 then
            verticalSpeed = math.clamp(heightDiff * 2, -80, 80)
        end
        
        -- 应用飞行速度
        local horizontalSpeed = CONFIG.FLY_SPEED
        local velocity = Vector3.new(
            direction.X * horizontalSpeed,
            verticalSpeed,
            direction.Z * horizontalSpeed
        )
        
        -- 确保BodyVelocity存在并设置速度
        if HerbState.FlightBodyVelocity then
            HerbState.FlightBodyVelocity.Velocity = velocity
            --if checkCount % 30 == 0 then
            --     print(string.format("[飞行] 设置速度向量: (%.1f, %.1f, %.1f)，速度大小: %.1f", 
            --        velocity.X, velocity.Y, velocity.Z, velocity.Magnitude))
            --end
        else
            warn("[飞行] FlightBodyVelocity不存在")
            return false
        end
        
        -- 等待一帧
        task.wait()
    end

    -- 清理飞行状态
    if HerbState.FlightBodyVelocity and HerbState.FlightBodyVelocity.Parent then
        HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    end
    
    if target and target.Parent then
        HerbState.timeoutHerbs[target] = tick()
        HerbState.currentTimeoutCount = HerbState.currentTimeoutCount + 1
        print("[飞行] " .. targetType .. "已销毁，已加入超时列表")
    end
    
    warn("[飞行] " .. targetType .. "已销毁或系统已停止，终止飞行")
    return false
end

-- ===================== 修复功法下降：确保下降到正确高度 =====================
local function descendToCollectHeight(target, isAura)
    if not target or not target.Parent then 
        warn("[下降] 目标不存在，无法下降")
        return false 
    end

    local targetType = isAura and "功法" or "草药"
    print("[高度] 开始下降到" .. targetType .. "采集高度")
    
    -- 确保角色状态
    if not humanoid or not humanoidRootPart then
        warn("[下降] 角色组件缺失")
        return false
    end
    
    -- 停止所有飞行运动
    if HerbState.FlightBodyVelocity and HerbState.FlightBodyVelocity.Parent then
        HerbState.FlightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
    end
    
    if HerbState.FlightBodyGyro and HerbState.FlightBodyGyro.Parent then
        HerbState.FlightBodyGyro:Destroy()
        HerbState.FlightBodyGyro = nil
    end
    
    -- 解除飞行状态
    HerbState.IsFlying = false
    if HerbState.FlightConnection then
        HerbState.FlightConnection:Disconnect()
        HerbState.FlightConnection = nil
    end
    
    -- 设置正常重力
    workspace.Gravity = HerbState.OriginalGravity

    -- 获取目标位置 - 关键修复：使用更可靠的方法
    local targetPos = Vector3.new(0, 0, 0)
    
    -- 方法1：直接查找ProximityPrompt并获取其父级位置
    local function findProximityPromptAndGetPosition(obj)
        for _, child in ipairs(obj:GetDescendants()) do
            if child:IsA("ProximityPrompt") then
                local parent = child.Parent
                if parent then
                    if parent:IsA("BasePart") then
                        return parent.Position
                    elseif parent:IsA("Model") then
                        if parent.PrimaryPart then
                            return parent.PrimaryPart.Position
                        else
                            -- 查找Model中的任何BasePart
                            for _, part in ipairs(parent:GetChildren()) do
                                if part:IsA("BasePart") then
                                    return part.Position
                                end
                            end
                        end
                    end
                end
                break
            end
        end
        return nil
    end
    
    local success, result = pcall(function()
        return findProximityPromptAndGetPosition(target)
    end)
    
    if success and result then
        targetPos = result
        print("[" .. targetType .. "下降] 通过ProximityPrompt找到位置: " .. tostring(targetPos))
    else
        -- 方法2：使用之前的方法作为备用
        if isAura then
            local success2, posResult = pcall(function()
                return getAuraPosition(target)
            end)
            if success2 and posResult then
                targetPos = posResult
            end
        else
            local success2, posResult = pcall(function()
                return getHerbPosition(target)
            end)
            if success2 and posResult then
                targetPos = posResult
            end
        end
        print("[" .. targetType .. "下降] 使用备用方法获取位置: " .. tostring(targetPos))
    end
    
    -- 检查是否获取到有效位置
    if targetPos == Vector3.new(0, 0, 0) then
        warn("[下降] 无法获取目标位置，使用当前位置上方5米")
        targetPos = humanoidRootPart.Position - Vector3.new(0, 5, 0)
    end
    
    -- 关键修复：确保下降高度正确
    -- 对于功法，应该下降到目标位置上方2-3米的位置
    local heightOffset = isAura and 2 or CONFIG.NORMAL_HEIGHT_OFFSET
    local targetHeight = targetPos.Y + heightOffset
    
    print(string.format("[下降] %s原始Y: %.2f，目标高度Y: %.2f，偏移: %d", 
        targetType, targetPos.Y, targetHeight, heightOffset))
    
    -- 确保目标高度不超过当前高度（避免往上飞）
    local currentY = humanoidRootPart.Position.Y
    if targetHeight > currentY then
        print(string.format("[下降] 目标高度(%.2f)高于当前位置(%.2f)，调整下降目标", targetHeight, currentY))
        targetHeight = currentY - 5  -- 下降5米
    end
    
    local finalTargetPos = Vector3.new(targetPos.X, targetHeight, targetPos.Z)
    
    print("[下降] 最终目标位置: " .. tostring(finalTargetPos))
    print("[下降] 当前玩家位置: " .. tostring(humanoidRootPart.Position))
    print(string.format("[下降] 垂直距离: %.2f米", currentY - targetHeight))

    -- 禁用飞行平台站立
    humanoid.PlatformStand = false
    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    humanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    
    -- 使用Tween平滑下降
    local tweenCompleted = false
    local tween
    
    -- 确保目标位置有效
    if finalTargetPos ~= Vector3.new(0, 0, 0) then
        print("[下降] 创建Tween动画，持续时间: " .. CONFIG.HEIGHT_TWEEN_TIME .. "秒")
        tween = TweenService:Create(
            humanoidRootPart,
            TweenInfo.new(CONFIG.HEIGHT_TWEEN_TIME, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
            {Position = finalTargetPos}
        )
        
        tween.Completed:Connect(function()
            tweenCompleted = true
            print("[下降] Tween动画完成，最终位置: " .. tostring(humanoidRootPart.Position))
        end)
        
        tween:Play()
        print("[下降] Tween动画已开始")
    else
        warn("[下降] 目标位置无效，跳过Tween动画")
        -- 直接设置位置
        humanoidRootPart.Position = finalTargetPos
        tweenCompleted = true
    end

    -- 等待下降完成
    local waitStart = tick()
    local maxWaitTime = CONFIG.HEIGHT_TWEEN_TIME * 3  -- 最多等待3倍的动画时间
    local waitCount = 0
    
    while not tweenCompleted and tick() - waitStart < maxWaitTime do
        local progress = (tick() - waitStart) / CONFIG.HEIGHT_TWEEN_TIME
        local currentPos = humanoidRootPart.Position
        waitCount = waitCount + 1
        
        if waitCount % 5 == 0 then  -- 每5次检查打印一次进度
            print(string.format("[下降] 进度: %.1f%% 当前位置: (%.2f, %.2f, %.2f)", 
                math.min(progress * 100, 100), currentPos.X, currentPos.Y, currentPos.Z))
        end
        task.wait(0.1)
    end
    
    if not tweenCompleted then
        warn("[下降] 下降动画超时，强制设置位置")
        if tween then
            tween:Cancel()
        end
        humanoidRootPart.Position = finalTargetPos
    else
        print("[下降] 下降动画成功完成")
    end
    
    -- 确保角色站立
    humanoid.PlatformStand = false
    humanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    
    print(string.format("[高度] 已下降到%s采集高度（%.2f米），等待用户采集", 
        targetType, targetHeight))
    return true
end

local function ascendToFlyHeight()
    print("[高度] 开始上升回飞行高度")
    
    humanoid.PlatformStand = true
    workspace.Gravity = HerbState.OriginalGravity * 0.1
    
    local targetPos = Vector3.new(humanoidRootPart.Position.X, CONFIG.FLY_HEIGHT, humanoidRootPart.Position.Z)

    local tweenCompleted = false
    local tween = TweenService:Create(
        humanoidRootPart,
        TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Position = targetPos}
    )
    tween.Completed:Connect(function() tweenCompleted = true end)
    tween:Play()

    local waitTime = 0
    while not tweenCompleted and waitTime < 2 do
        waitTime += task.wait(0.1)
    end
    if not tweenCompleted then
        warn("[高度] 上升动画超时，强制设置位置")
        tween:Cancel()
        humanoidRootPart.Position = targetPos
    end

    enableFlight()
    HerbState.currentHerb = nil
    AuraState.currentAura = nil
    print("[高度] 已回到飞行高度")
end

local function waitForPlayerCollect(target, isAura)
    if not target then 
        local targetType = isAura and "功法" or "草药"
        print("[采集] " .. targetType .. "不存在，终止等待")
        return false 
    end

    local targetType = isAura and "功法" or "草药"
    print("[采集] 等待用户采集" .. targetType .. "：" .. target.Name .. "（超时：" .. CONFIG.COLLECT_TIMEOUT .. "秒）")
    local startTime = tick()
    local checkInterval = 0.2

    while HerbState.isRunning do
        if not target:IsDescendantOf(Workspace) or not target.Parent then
            print("[采集] 检测到" .. targetType .. "已被采集")
            HerbState.collectedHerbs[target] = true
            HerbState.herbAgeCache[target] = nil
            HerbState.timeoutHerbs[target] = nil
            HerbState.currentTimeoutCount = 0
            HerbState.retryAttempts = 0
            return true
        end

        local elapsedTime = tick() - startTime
        if elapsedTime >= CONFIG.COLLECT_TIMEOUT then
            print("[采集] 采集超时（" .. CONFIG.COLLECT_TIMEOUT .. "秒未采集）")
            HerbState.timeoutHerbs[target] = tick()
            HerbState.currentTimeoutCount = HerbState.currentTimeoutCount + 1
            print("[采集] 已将" .. targetType .. " " .. target.Name .. " 加入超时列表（冷却时间：" .. CONFIG.TIMEOUT_COOLDOWN .. "秒）")
            return false
        end

        task.wait(checkInterval)
    end

    print("[采集] 系统已停止，终止等待")
    return false
end

local function findAlternativeTarget(excludeTarget, excludeIsAura)
    print("[寻找] 正在寻找替代目标...")
    
    -- 1. 优先查找其他功法（如果目标模式包含功法）
    if HerbState.targetMode == "aura" or HerbState.targetMode == "both" then
        local allAuras = scanAuras()
        if #allAuras > 0 then
            for _, aura in ipairs(allAuras) do
                if aura and aura ~= excludeTarget and aura.Parent then
                    local isTimedOut = false
                    for timeoutAura, timeoutTime in pairs(HerbState.timeoutHerbs) do
                        if timeoutAura and timeoutAura == aura then
                            if tick() - timeoutTime < CONFIG.TIMEOUT_COOLDOWN then
                                isTimedOut = true
                            end
                            break
                        end
                    end
                    
                    if not isTimedOut then
                        local auraPos = getAuraPosition(aura)
                        local currentPos = excludeTarget and getHerbPosition(excludeTarget) or humanoidRootPart.Position
                        local distance = (auraPos - currentPos).Magnitude
                        
                        print(string.format("[寻找] 找到替代功法: %s (距离: %.1f米)", aura.Name, distance))
                        return aura, true
                    end
                end
            end
        end
    end
    
    -- 2. 查找草药（如果目标模式包含草药）
    if HerbState.targetMode == "herb" or HerbState.targetMode == "both" then
        local allHerbs = scanHerbs()
        if #allHerbs == 0 then 
            print("[寻找] 未找到任何替代目标")
            return nil, false 
        end

        local priorityHerbs, nonPriorityHerbs, hasPriority = filterHerbsByPriority(allHerbs)
        
        local herbInfoList = {}
        local currentPos = excludeTarget and getHerbPosition(excludeTarget) or humanoidRootPart.Position
        
        if hasPriority and #priorityHerbs > 0 then
            for _, priorityInfo in ipairs(priorityHerbs) do
                local herb = priorityInfo.herb
                local priority = priorityInfo.priority
                
                if herb and herb ~= excludeTarget and herb.Parent then
                    local isTimedOut = false
                    for timeoutHerb, timeoutTime in pairs(HerbState.timeoutHerbs) do
                        if timeoutHerb and timeoutHerb == herb then
                            if tick() - timeoutTime < CONFIG.TIMEOUT_COOLDOWN then
                                isTimedOut = true
                            end
                            break
                        end
                    end
                    
                    if not isTimedOut then
                        local age = getHerbAge(herb)
                        local herbPos = getHerbPosition(herb)
                        local distance = (herbPos - currentPos).Magnitude
                        
                        table.insert(herbInfoList, {
                            herb = herb,
                            age = age,
                            distance = distance,
                            isPriority = true,
                            priority = priority
                        })
                    end
                end
            end
        end
        
        for _, herb in ipairs(nonPriorityHerbs) do
            if herb and herb ~= excludeTarget and herb.Parent then
                local isTimedOut = false
                for timeoutHerb, timeoutTime in pairs(HerbState.timeoutHerbs) do
                    if timeoutHerb and timeoutHerb == herb then
                        if tick() - timeoutTime < CONFIG.TIMEOUT_COOLDOWN then
                            isTimedOut = true
                        end
                        break
                    end
                end
                
                if not isTimedOut then
                    local age = getHerbAge(herb)
                    local herbPos = getHerbPosition(herb)
                    local distance = (herbPos - currentPos).Magnitude
                    
                    table.insert(herbInfoList, {
                        herb = herb,
                        age = age,
                        distance = distance,
                        isPriority = false
                    })
                end
            end
        end
        
        if #herbInfoList == 0 then
            print("[寻找] 没有其他可用的替代目标")
            return nil, false
        end
        
        table.sort(herbInfoList, function(a, b)
            if a.isPriority and b.isPriority then
                if a.priority ~= b.priority then
                    return a.priority < b.priority
                elseif a.age ~= b.age then
                    return a.age > b.age
                else
                    return a.distance < b.distance
                end
            elseif a.isPriority and not b.isPriority then
                return true
            elseif not a.isPriority and b.isPriority then
                return false
            else
                if a.age ~= b.age then
                    return a.age > b.age
                else
                    return a.distance < b.distance
                end
            end
        end)
        
        local bestAlternative = herbInfoList[1].herb
        local bestAge = herbInfoList[1].age
        local bestDistance = herbInfoList[1].distance
        
        print(string.format("[寻找] 找到最佳替代草药: %s (年份: %d, 距离: %.1f米)", 
            bestAlternative.Name, bestAge, bestDistance))
        
        return bestAlternative, false
    end
    
    print("[寻找] 没有其他可用的替代目标")
    return nil, false
end

local function resetScanState()
    print("[重置] 正在重置扫描状态...")
    
    HerbState.collectedHerbs = {}
    HerbState.timeoutHerbs = {}
    HerbState.herbAgeCache = {}
    HerbState.modifiedHerbs = {}  -- 也重置修改记录
    
    print("[重置] 扫描状态已重置")
end

local function mainLoop()
    print("[主流程] 启动，开始寻找目标...")
    
    if #HerbState.priorityHerbs > 0 then
        print("[主流程] 优先级草药设置:")
        for _, priorityHerb in ipairs(HerbState.priorityHerbs) do
            print(string.format("  优先级%d: %s", priorityHerb.priority, priorityHerb.name))
        end
    else
        print("[主流程] 未设置优先级草药")
    end
    
    print("[主流程] 目标模式: " .. HerbState.targetMode)
    print("[主流程] 黑名单草药: " .. table.concat(CONFIG.BLACKLIST_HERBS, ", "))
    
    HerbState.currentTimeoutCount = 0
    HerbState.failCount = 0

    while HerbState.isRunning do
        if not HerbState.isRunning then
            break
        end
        
        HerbState.currentHerb = nil
        AuraState.currentAura = nil
        
        -- 清理已采集的草药记录
        HerbState.collectedHerbs = {}
        
        print("[主流程] 重新扫描草药列表...")
        
        -- 寻找目标
        local success, bestTarget, isAura = pcall(function()
            return findBestTarget()
        end)
        
        if not success then
            print("[主流程] 寻找目标时发生错误，5秒后重试")
            warn("[主流程] 错误详情: " .. tostring(bestTarget))
            
            disableFlight()
            task.wait(5)
            continue
        end
        
        if not bestTarget then
            print("[主流程] 未找到任何目标，5秒后重试")
            disableFlight()
            
            for i = 1, 50 do
                if not HerbState.isRunning then
                    break
                end
                task.wait(0.1)
            end
            continue
        end
        
        if not HerbState.isRunning then
            break
        end
        
        if isAura then
            AuraState.currentAura = bestTarget
            print(string.format("[主流程] 选择功法：%s", bestTarget.Name))
        else
            HerbState.currentHerb = bestTarget
            local priority = getHerbPriority(bestTarget.Name)
            print(string.format("[主流程] 选择草药：%s%s", bestTarget.Name, priority and " [优先级" .. priority .. "]" or ""))
        end

        -- 启用飞行
        enableFlight()
        
        -- 等待飞行完全启用
        for i = 1, 10 do
            if not HerbState.isRunning then break end
            if HerbState.IsFlying and HerbState.FlightBodyVelocity then break end
            task.wait(0.1)
        end
        
        if not HerbState.isRunning then
            break
        end
        
        if not HerbState.IsFlying then
            print("[主流程] 飞行模式未能启用，重新尝试")
            enableFlight()
            task.wait(1)
        end
        
        if not HerbState.IsFlying then
            print("[主流程] 飞行模式仍然未启用，跳过当前目标")
            task.wait(2)
            continue
        end
        
        -- 飞行到目标
        print("[主流程] 开始飞行到目标...")
        local reachSuccess = flyToTarget(bestTarget, isAura)
        
        if not HerbState.isRunning then
            disableFlight()
            break
        end
        
        if not reachSuccess then
            print("[主流程] 未能到达目标位置，寻找替代目标...")
            
            local alternativeTarget, altIsAura = findAlternativeTarget(bestTarget, isAura)
            if alternativeTarget then
                print("[主流程] 找到替代目标：" .. alternativeTarget.Name)
                if altIsAura then
                    AuraState.currentAura = alternativeTarget
                else
                    HerbState.currentHerb = alternativeTarget
                end
                
                local altReachSuccess = flyToTarget(alternativeTarget, altIsAura)
                if not altReachSuccess then
                    print("[主流程] 替代目标也无法到达，继续寻找下一个...")
                    if HerbState.isRunning then
                        ascendToFlyHeight()
                    end
                    task.wait(2)
                    continue
                end
                bestTarget = alternativeTarget
                isAura = altIsAura
            else
                print("[主流程] 未找到替代目标，2秒后重新寻找")
                if HerbState.isRunning then
                    ascendToFlyHeight()
                end
                task.wait(2)
                continue
            end
        end

        print("[主流程] 飞行到达成功，准备下降...")
        
        if not HerbState.isRunning then
            disableFlight()
            break
        end
        
        -- 执行下降
        print("[主流程] 开始下降到采集高度...")
        local descendSuccess = descendToCollectHeight(bestTarget, isAura)
        
        if not descendSuccess then
            print("[主流程] 下降失败，寻找替代目标...")
            
            local alternativeTarget, altIsAura = findAlternativeTarget(bestTarget, isAura)
            if alternativeTarget then
                print("[主流程] 找到替代目标：" .. alternativeTarget.Name)
                if altIsAura then
                    AuraState.currentAura = alternativeTarget
                else
                    HerbState.currentHerb = alternativeTarget
                end
                
                print("[主流程] 重新前往替代目标...")
                if HerbState.isRunning then
                    ascendToFlyHeight()
                end
                task.wait(1)
                continue
            else
                print("[主流程] 未找到替代目标，2秒后重新寻找")
                if HerbState.isRunning then
                    ascendToFlyHeight()
                end
                task.wait(2)
                continue
            end
        end

        if not HerbState.isRunning then
            disableFlight()
            break
        end
        
        print("[主流程] 下降完成，等待用户采集...")
        local collectSuccess = waitForPlayerCollect(bestTarget, isAura)
        
        if collectSuccess then
            print("[主流程] 目标采集成功，准备下一个")
            if HerbState.isRunning then
                ascendToFlyHeight()
            end
            
            HerbState.currentHerb = nil
            AuraState.currentAura = nil
            
            task.wait(0.5)
            continue
        else
            print("[主流程] 采集超时，当前超时次数：" .. HerbState.currentTimeoutCount)
            
            if HerbState.currentTimeoutCount >= CONFIG.MAX_RETRY_ATTEMPTS then
                print("[主流程] 达到最大超时次数（" .. CONFIG.MAX_RETRY_ATTEMPTS .. "），寻找替代目标...")
            end
            
            local alternativeTarget, altIsAura = findAlternativeTarget(bestTarget, isAura)
            if alternativeTarget then
                print("[主流程] 切换到替代目标：" .. alternativeTarget.Name)
                if altIsAura then
                    AuraState.currentAura = alternativeTarget
                else
                    HerbState.currentHerb = alternativeTarget
                end
                
                if HerbState.isRunning then
                    print("[主流程] 立即前往替代目标...")
                    ascendToFlyHeight()
                end
                continue
            else
                print("[主流程] 未找到替代目标")
                
                if HerbState.currentTimeoutCount >= CONFIG.MAX_RETRY_ATTEMPTS then
                    print("[主流程] 连续超时次数过多，停止系统")
                    HerbState.isRunning = false
                    break
                else
                    print("[主流程] 将在3秒后重新寻找目标")
                    if HerbState.isRunning then
                        ascendToFlyHeight()
                    end
                    task.wait(3)
                    continue
                end
            end
        end
    end

    disableFlight()
    HerbState.currentHerb = nil
    AuraState.currentAura = nil
    HerbState.retryAttempts = 0
    HerbState.currentTimeoutCount = 0
    HerbState.failCount = 0
    print("[主流程] 已停止")
end

local function startHerbSystem()
    if HerbState.isRunning then
        print("[系统] 系统已经在运行中")
        return false
    end
    
    print("[系统] 正在启动系统...")
    
    HerbState.retryAttempts = 0
    HerbState.currentTimeoutCount = 0
    HerbState.collectedHerbs = {}
    HerbState.timeoutHerbs = {}
    HerbState.herbAgeCache = {}
    HerbState.failCount = 0
    HerbState.currentHerb = nil
    AuraState.currentAura = nil
    HerbState.IsFlying = false
    
    if HerbState.FlightBodyVelocity then
        HerbState.FlightBodyVelocity:Destroy()
        HerbState.FlightBodyVelocity = nil
    end
    if HerbState.FlightBodyGyro then
        HerbState.FlightBodyGyro:Destroy()
        HerbState.FlightBodyGyro = nil
    end
    if HerbState.FlightConnection then
        HerbState.FlightConnection:Disconnect()
        HerbState.FlightConnection = nil
    end
    
    HerbState.isRunning = true
    
    -- 修复：启动系统时不改变目标模式，保持当前设置
    print("[系统] 启动系统，当前目标模式: " .. HerbState.targetMode)
    
    -- 如果开启了一键加速，重新设置监听器
    if HerbState.quickPickEnabled then
        setupQuickPickListener()
    end
    
    -- 使用task.spawn替代coroutine，更稳定
    task.spawn(function()
        mainLoop()
    end)
    
    print("[系统] 系统已成功启动")
    return true
end

local function stopHerbSystem()
    if not HerbState.isRunning then
        print("[系统] 系统未在运行")
        return false
    end
    
    print("[系统] 正在停止系统...")
    
    HerbState.isRunning = false
    
    -- 停止所有运动
    StopAllMovement()
    HerbState.currentHerb = nil
    AuraState.currentAura = nil
    
    print("[系统] 系统已停止")
    return true
end

-- ===================== 从ReplicatedStorage.Models.Herbs加载草药类型 =====================
local function loadHerbTypesFromReplicatedStorage()
    local herbsList = {}
    local seenNames = {}
    
    print("[草药列表] 从ReplicatedStorage.Models.Herbs文件夹加载...")
    
    -- 从ReplicatedStorage.Models.Herbs文件夹加载
    local herbsFolder = ReplicatedStorage:FindFirstChild("Models")
    if herbsFolder then
        herbsFolder = herbsFolder:FindFirstChild("Herbs")
    end
    
    if herbsFolder then
        print("[草药列表] 找到ReplicatedStorage.Models.Herbs文件夹")
        
        -- 遍历所有草药对象
        for _, item in ipairs(herbsFolder:GetChildren()) do
            if not item then continue end
            
            local herbName = item.Name
            
            -- 检查是否是黑名单草药
            local isBlacklisted = false
            for _, blacklistName in ipairs(CONFIG.BLACKLIST_HERBS) do
                if herbName == blacklistName or herbName:match(blacklistName) then
                    isBlacklisted = true
                    print("[草药列表] 跳过黑名单草药: " .. herbName)
                    break
                end
            end
            
            if isBlacklisted then
                continue
            end
            
            -- 检查是否是草药对象
            local isHerbObject = false
            
            -- 如果是Model，MeshPart或Part，都认为是草药
            if item:IsA("Model") or item:IsA("MeshPart") or item:IsA("Part") then
                isHerbObject = true
            end
            
            if isHerbObject and not seenNames[herbName] then
                table.insert(herbsList, herbName)
                seenNames[herbName] = true
                print("[草药列表] 添加草药: " .. herbName)
            end
        end
    else
        print("[草药列表] 未找到ReplicatedStorage.Models.Herbs文件夹，使用默认列表")
        herbsList = {
            "Extreme Yin Growth",
            "Extreme Yang Growth", 
            "Yin Growth",
            "Yang Growth",
            "Spiritual Growth",
            "Herbal Growth",
            "Mystic Growth"
        }
    end
    
    table.sort(herbsList)
    HerbState.availableHerbTypes = herbsList
    
    print("[草药列表] 已加载 " .. #herbsList .. " 种草药类型")
    
    return herbsList
end

-- ===================== 优先级选择UI =====================
local PriorityUI = nil

local function createPrioritySelectionUI()
    if PriorityUI then
        PriorityUI:Destroy()
        PriorityUI = nil
        HerbState.isPriorityUIOpen = false
        return
    end
    
    if HerbState.isPriorityUIOpen then
        print("[优先级] 优先级UI已打开")
        return
    end
    
    print("[优先级] 创建优先级选择UI")
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "PrioritySelectionUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.DisplayOrder = 20
    
    local UI = CONFIG.UI_SCALE
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, UI.PRIORITY_FRAME_WIDTH, 0, UI.PRIORITY_FRAME_HEIGHT)
    mainFrame.Position = UDim2.new(0.5, -UI.PRIORITY_FRAME_WIDTH/2, 0.5, -UI.PRIORITY_FRAME_HEIGHT/2)
    mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = true
    
    -- 标题
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    titleLabel.Text = "优先级草药选择"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = UI.TITLE_TEXT_SIZE
    titleLabel.BorderSizePixel = 0
    
    -- 说明
    local instructionLabel = Instance.new("TextLabel")
    instructionLabel.Name = "Instruction"
    instructionLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 50)
    instructionLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 45)
    instructionLabel.BackgroundTransparency = 1
    instructionLabel.Text = "选择优先级草药（最多" .. CONFIG.MAX_PRIORITY_HERBS .. "种）\n选择的顺序即为优先级顺序"
    instructionLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    instructionLabel.Font = Enum.Font.SourceSans
    instructionLabel.TextSize = UI.SMALL_TEXT_SIZE
    instructionLabel.TextWrapped = true
    instructionLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 选择数量显示
    local selectionLabel = Instance.new("TextLabel")
    selectionLabel.Name = "SelectionLabel"
    selectionLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    selectionLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 100)
    selectionLabel.BackgroundTransparency = 1
    selectionLabel.Text = "已选择: 0/" .. CONFIG.MAX_PRIORITY_HERBS
    selectionLabel.TextColor3 = Color3.fromRGB(200, 255, 200)
    selectionLabel.Font = Enum.Font.SourceSansBold
    selectionLabel.TextSize = UI.BODY_TEXT_SIZE
    selectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 优先级列表区域
    local priorityFrame = Instance.new("Frame")
    priorityFrame.Name = "PriorityFrame"
    priorityFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 120)
    priorityFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 130)
    priorityFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    priorityFrame.BorderSizePixel = 0
    
    local priorityTitle = Instance.new("TextLabel")
    priorityTitle.Name = "PriorityTitle"
    priorityTitle.Size = UDim2.new(1, 0, 0, 25)
    priorityTitle.Position = UDim2.new(0, 0, 0, 0)
    priorityTitle.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
    priorityTitle.Text = "优先级列表 (点击移除)"
    priorityTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    priorityTitle.Font = Enum.Font.SourceSansBold
    priorityTitle.TextSize = UI.BODY_TEXT_SIZE
    priorityTitle.BorderSizePixel = 0
    
    local priorityScroll = Instance.new("ScrollingFrame")
    priorityScroll.Name = "PriorityScroll"
    priorityScroll.Size = UDim2.new(1, 0, 1, -25)
    priorityScroll.Position = UDim2.new(0, 0, 0, 25)
    priorityScroll.BackgroundTransparency = 1
    priorityScroll.BorderSizePixel = 0
    priorityScroll.ScrollBarThickness = 8
    priorityScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    -- 草药列表区域
    local herbsFrame = Instance.new("Frame")
    herbsFrame.Name = "HerbsFrame"
    herbsFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 200)
    herbsFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 255)
    herbsFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    herbsFrame.BorderSizePixel = 0
    
    local herbsTitle = Instance.new("TextLabel")
    herbsTitle.Name = "HerbsTitle"
    herbsTitle.Size = UDim2.new(1, 0, 0, 25)
    herbsTitle.Position = UDim2.new(0, 0, 0, 0)
    herbsTitle.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
    herbsTitle.Text = "草药列表 (点击选择)"
    herbsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbsTitle.Font = Enum.Font.SourceSansBold
    herbsTitle.TextSize = UI.BODY_TEXT_SIZE
    herbsTitle.BorderSizePixel = 0
    
    local herbsScroll = Instance.new("ScrollingFrame")
    herbsScroll.Name = "HerbsScroll"
    herbsScroll.Size = UDim2.new(1, 0, 1, -25)
    herbsScroll.Position = UDim2.new(0, 0, 0, 25)
    herbsScroll.BackgroundTransparency = 1
    herbsScroll.BorderSizePixel = 0
    herbsScroll.ScrollBarThickness = 8
    herbsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    -- 按钮区域
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Name = "ButtonFrame"
    buttonFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 50)
    buttonFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, UI.PRIORITY_FRAME_HEIGHT - 60)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.BorderSizePixel = 0
    
    -- 按钮
    local confirmButton = Instance.new("TextButton")
    confirmButton.Name = "ConfirmButton"
    confirmButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    confirmButton.Position = UDim2.new(0.025, 0, 0, 5)
    confirmButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    confirmButton.Text = "确认"
    confirmButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    confirmButton.Font = Enum.Font.SourceSansBold
    confirmButton.TextSize = UI.BUTTON_TEXT_SIZE
    confirmButton.BorderSizePixel = 0
    
    local cancelButton = Instance.new("TextButton")
    cancelButton.Name = "CancelButton"
    cancelButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    cancelButton.Position = UDim2.new(0.525, 0, 0, 5)
    cancelButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    cancelButton.Text = "取消"
    cancelButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cancelButton.Font = Enum.Font.SourceSans
    cancelButton.TextSize = UI.BUTTON_TEXT_SIZE
    cancelButton.BorderSizePixel = 0
    
    local clearButton = Instance.new("TextButton")
    clearButton.Name = "ClearButton"
    clearButton.Size = UDim2.new(0.45, 0, 0, 28)
    clearButton.Position = UDim2.new(0.275, 0, 0, UI.BUTTON_HEIGHT + 10)
    clearButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
    clearButton.Text = "清空选择"
    clearButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    clearButton.Font = Enum.Font.SourceSans
    clearButton.TextSize = UI.SMALL_TEXT_SIZE
    clearButton.BorderSizePixel = 0
    
    -- 状态管理
    local selectedHerbs = {}
    local selectedCount = 0
    
    local function updateSelectionDisplay()
        selectionLabel.Text = string.format("已选择: %d/%d", selectedCount, CONFIG.MAX_PRIORITY_HERBS)
        
        if selectedCount >= CONFIG.MAX_PRIORITY_HERBS then
            selectionLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            selectionLabel.Text = selectionLabel.Text .. " (已达上限)"
        else
            selectionLabel.TextColor3 = Color3.fromRGB(200, 255, 200)
        end
    end
    
    local function createPriorityItem(index, herbName)
        local itemFrame = Instance.new("TextButton")
        itemFrame.Name = "PriorityItem_" .. index
        itemFrame.Size = UDim2.new(1, -10, 0, 30)
        itemFrame.Position = UDim2.new(0, 5, 0, (index-1) * 32)
        itemFrame.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
        itemFrame.Text = ""
        itemFrame.BorderSizePixel = 0
        
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 8)
        layout.Parent = itemFrame
        
        local priorityLabel = Instance.new("TextLabel")
        priorityLabel.Name = "Priority"
        priorityLabel.Size = UDim2.new(0, 40, 1, 0)
        priorityLabel.LayoutOrder = 1
        priorityLabel.BackgroundTransparency = 1
        priorityLabel.Text = "#" .. index
        priorityLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
        priorityLabel.Font = Enum.Font.SourceSansBold
        priorityLabel.TextSize = 14
        priorityLabel.TextXAlignment = Enum.TextXAlignment.Center
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "Name"
        nameLabel.Size = UDim2.new(1, -50, 1, 0)
        nameLabel.LayoutOrder = 2
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = herbName
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.SourceSans
        nameLabel.TextSize = 14
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        
        itemFrame.MouseButton1Click:Connect(function()
            for idx, name in ipairs(selectedHerbs) do
                if name == herbName then
                    table.remove(selectedHerbs, idx)
                    selectedCount = selectedCount - 1
                    break
                end
            end
            
            -- 重新创建优先级列表
            for _, child in ipairs(priorityScroll:GetChildren()) do
                if child:IsA("Frame") or child:IsA("TextButton") then
                    child:Destroy()
                end
            end
            
            for i, name in ipairs(selectedHerbs) do
                createPriorityItem(i, name)
            end
            
            -- 重新创建草药列表以更新选择状态
            for _, child in ipairs(herbsScroll:GetChildren()) do
                if child:IsA("Frame") or child:IsA("TextButton") then
                    local nameLabel = child:FindFirstChild("Name")
                    if nameLabel then
                        local isSelected = false
                        for _, selectedName in ipairs(selectedHerbs) do
                            if selectedName == nameLabel.Text then
                                isSelected = true
                                break
                            end
                        end
                        
                        local checkmark = child:FindFirstChild("Checkmark")
                        if checkmark then
                            checkmark.Visible = isSelected
                        end
                        
                        child.BackgroundColor3 = isSelected and Color3.fromRGB(80, 120, 80) or Color3.fromRGB(60, 60, 80)
                    end
                end
            end
            
            updateSelectionDisplay()
            print("[优先级] 已移除草药: " .. herbName)
        end)
        
        priorityLabel.Parent = itemFrame
        nameLabel.Parent = itemFrame
        itemFrame.Parent = priorityScroll
        
        return itemFrame
    end
    
    local function updatePriorityList()
        for _, child in ipairs(priorityScroll:GetChildren()) do
            if child:IsA("Frame") or child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        for i, herbName in ipairs(selectedHerbs) do
            createPriorityItem(i, herbName)
        end
        
        -- 更新滚动区域大小
        priorityScroll.CanvasSize = UDim2.new(0, 0, 0, #selectedHerbs * 32)
    end
    
    -- 加载草药列表
    local herbsList = loadHerbTypesFromReplicatedStorage()
    
    -- 初始化已选择的草药
    for _, priorityHerb in ipairs(HerbState.priorityHerbs) do
        table.insert(selectedHerbs, priorityHerb.name)
        selectedCount = selectedCount + 1
    end
    
    for i, herbName in ipairs(herbsList) do
        local itemFrame = Instance.new("TextButton")
        itemFrame.Name = "HerbItem_" .. i
        itemFrame.Size = UDim2.new(1, -10, 0, UI.HERB_ITEM_HEIGHT)
        itemFrame.Position = UDim2.new(0, 5, 0, (i-1) * (UI.HERB_ITEM_HEIGHT + 2))
        itemFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
        itemFrame.Text = ""
        itemFrame.BorderSizePixel = 0
        
        local layout = Instance.new("UIListLayout")
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.SortOrder = Enum.SortOrder.LayoutOrder
        layout.Padding = UDim.new(0, 8)
        layout.Parent = itemFrame
        
        local checkbox = Instance.new("Frame")
        checkbox.Name = "Checkbox"
        checkbox.Size = UDim2.new(0, 24, 0, 24)
        checkbox.LayoutOrder = 1
        checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
        checkbox.BorderSizePixel = 0
        
        local checkmark = Instance.new("TextLabel")
        checkmark.Name = "Checkmark"
        checkmark.Size = UDim2.new(1, 0, 1, 0)
        checkmark.Position = UDim2.new(0, 0, 0, 0)
        checkmark.BackgroundTransparency = 1
        checkmark.Text = "✓"
        checkmark.TextColor3 = Color3.fromRGB(100, 255, 100)
        checkmark.Font = Enum.Font.SourceSansBold
        checkmark.TextSize = 18
        checkmark.Visible = false
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "Name"
        nameLabel.Size = UDim2.new(1, -30, 1, 0)
        nameLabel.LayoutOrder = 2
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = herbName
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.SourceSans
        nameLabel.TextSize = UI.BODY_TEXT_SIZE
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        
        -- 检查是否已经选择
        local isSelected = false
        for _, selectedName in ipairs(selectedHerbs) do
            if selectedName == herbName then
                isSelected = true
                checkmark.Visible = true
                itemFrame.BackgroundColor3 = Color3.fromRGB(80, 120, 80)
                checkbox.BackgroundColor3 = Color3.fromRGB(100, 150, 100)
                break
            end
        end
        
        itemFrame.MouseButton1Click:Connect(function()
            if isSelected then
                isSelected = false
                checkmark.Visible = false
                itemFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
                checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
                
                for idx, name in ipairs(selectedHerbs) do
                    if name == herbName then
                        table.remove(selectedHerbs, idx)
                        selectedCount = selectedCount - 1
                        break
                    end
                end
                
                print("[优先级] 已取消选择草药: " .. herbName)
            else
                if selectedCount >= CONFIG.MAX_PRIORITY_HERBS then
                    print("[优先级] 已达到最大选择数量 (" .. CONFIG.MAX_PRIORITY_HERBS .. ")，无法选择更多草药")
                    return
                end
                
                isSelected = true
                checkmark.Visible = true
                itemFrame.BackgroundColor3 = Color3.fromRGB(80, 120, 80)
                checkbox.BackgroundColor3 = Color3.fromRGB(100, 150, 100)
                
                table.insert(selectedHerbs, herbName)
                selectedCount = selectedCount + 1
                
                print("[优先级] 已选择草药: " .. herbName .. " (优先级: " .. selectedCount .. ")")
            end
            
            updatePriorityList()
            updateSelectionDisplay()
        end)
        
        checkmark.Parent = checkbox
        checkbox.Parent = itemFrame
        nameLabel.Parent = itemFrame
        itemFrame.Parent = herbsScroll
    end
    
    -- 更新滚动区域大小
    herbsScroll.CanvasSize = UDim2.new(0, 0, 0, #herbsList * (UI.HERB_ITEM_HEIGHT + 2))
    
    -- 按钮事件
    confirmButton.MouseButton1Click:Connect(function()
        HerbState.priorityHerbs = {}
        
        for i, herbName in ipairs(selectedHerbs) do
            table.insert(HerbState.priorityHerbs, {
                name = herbName,
                priority = i
            })
        end
        
        print("[优先级] 已保存 " .. #HerbState.priorityHerbs .. " 种优先级草药")
        
        for _, priorityHerb in ipairs(HerbState.priorityHerbs) do
            print(string.format("[优先级] 优先级%d: %s", priorityHerb.priority, priorityHerb.name))
        end
        
        screenGui:Destroy()
        PriorityUI = nil
        HerbState.isPriorityUIOpen = false
    end)
    
    cancelButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        PriorityUI = nil
        HerbState.isPriorityUIOpen = false
        print("[优先级] 已取消选择")
    end)
    
    clearButton.MouseButton1Click:Connect(function()
        selectedHerbs = {}
        selectedCount = 0
        
        for _, child in ipairs(herbsScroll:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
                local checkbox = child:FindFirstChild("Checkbox")
                if checkbox then
                    checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
                    local checkmark = checkbox:FindFirstChild("Checkmark")
                    if checkmark then
                        checkmark.Visible = false
                    end
                end
            end
        end
        
        updatePriorityList()
        updateSelectionDisplay()
        print("[优先级] 已清空所有选择")
    end)
    
    -- 关闭事件
    screenGui.Destroying:Connect(function()
        HerbState.isPriorityUIOpen = false
        PriorityUI = nil
    end)
    
    updatePriorityList()
    updateSelectionDisplay()
    
    -- 组装UI
    priorityTitle.Parent = priorityFrame
    priorityScroll.Parent = priorityFrame
    herbsTitle.Parent = herbsFrame
    herbsScroll.Parent = herbsFrame
    
    titleLabel.Parent = mainFrame
    instructionLabel.Parent = mainFrame
    selectionLabel.Parent = mainFrame
    priorityFrame.Parent = mainFrame
    herbsFrame.Parent = mainFrame
    
    confirmButton.Parent = buttonFrame
    cancelButton.Parent = buttonFrame
    clearButton.Parent = buttonFrame
    buttonFrame.Parent = mainFrame
    
    mainFrame.Parent = screenGui
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    PriorityUI = screenGui
    HerbState.isPriorityUIOpen = true
    
    return screenGui
end

-- ===================== 炼药UI界面 =====================
local PillUI = nil

local function createPillUI()
    if PillUI then
        PillUI:Destroy()
        PillUI = nil
        PillState.isPillUIOpen = false
        return
    end
    
    if PillState.isPillUIOpen then
        print("[炼药] 炼药UI已打开")
        return
    end
    
    print("[炼药] 创建炼药设置UI")
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "PillSettingUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.DisplayOrder = 20
    
    local UI = CONFIG.UI_SCALE
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 500, 0, 550) -- 增加高度以适应间隔设置
    mainFrame.Position = UDim2.new(0.5, -250, 0.5, -275)
    mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = true
    
    -- 标题
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 40)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    titleLabel.Text = "炼药设置"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = UI.TITLE_TEXT_SIZE
    titleLabel.BorderSizePixel = 0
    
    -- 说明
    local instructionLabel = Instance.new("TextLabel")
    instructionLabel.Name = "Instruction"
    instructionLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 50)
    instructionLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 45)
    instructionLabel.BackgroundTransparency = 1
    instructionLabel.Text = "选择丹药类型并设置炼制次数和间隔"
    instructionLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    instructionLabel.Font = Enum.Font.SourceSans
    instructionLabel.TextSize = UI.SMALL_TEXT_SIZE
    instructionLabel.TextWrapped = true
    instructionLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 当前选择显示
    local currentSelectionLabel = Instance.new("TextLabel")
    currentSelectionLabel.Name = "CurrentSelectionLabel"
    currentSelectionLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    currentSelectionLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 100)
    currentSelectionLabel.BackgroundTransparency = 1
    currentSelectionLabel.Text = "当前选择: " .. PillState.currentPillType
    currentSelectionLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    currentSelectionLabel.Font = Enum.Font.SourceSansBold
    currentSelectionLabel.TextSize = UI.BODY_TEXT_SIZE
    currentSelectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 炼制次数设置
    local countLabel = Instance.new("TextLabel")
    countLabel.Name = "CountLabel"
    countLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    countLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 130)
    countLabel.BackgroundTransparency = 1
    countLabel.Text = "炼制次数: " .. PillState.craftCount
    countLabel.TextColor3 = Color3.fromRGB(200, 255, 200)
    countLabel.Font = Enum.Font.SourceSansBold
    countLabel.TextSize = UI.BODY_TEXT_SIZE
    countLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 炼制次数输入框
    local countFrame = Instance.new("Frame")
    countFrame.Name = "CountFrame"
    countFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, UI.BUTTON_HEIGHT)
    countFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 160)
    countFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    countFrame.BorderSizePixel = 0
    
    local countTextBox = Instance.new("TextBox")
    countTextBox.Name = "CountTextBox"
    countTextBox.Size = UDim2.new(0.7, 0, 1, 0)
    countTextBox.Position = UDim2.new(0, 0, 0, 0)
    countTextBox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
    countTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    countTextBox.Font = Enum.Font.SourceSans
    countTextBox.Text = tostring(PillState.craftCount)
    countTextBox.TextSize = UI.BUTTON_TEXT_SIZE
    countTextBox.BorderSizePixel = 0
    countTextBox.PlaceholderText = "输入炼制次数 (1-1000)"
    
    local countApplyButton = Instance.new("TextButton")
    countApplyButton.Name = "CountApplyButton"
    countApplyButton.Size = UDim2.new(0.3, 0, 1, 0)
    countApplyButton.Position = UDim2.new(0.7, 0, 0, 0)
    countApplyButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    countApplyButton.Text = "应用"
    countApplyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    countApplyButton.Font = Enum.Font.SourceSansBold
    countApplyButton.TextSize = UI.BUTTON_TEXT_SIZE
    countApplyButton.BorderSizePixel = 0
    
    -- 炼制间隔设置
    local intervalLabel = Instance.new("TextLabel")
    intervalLabel.Name = "IntervalLabel"
    intervalLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    intervalLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 205)
    intervalLabel.BackgroundTransparency = 1
    intervalLabel.Text = "炼药间隔: " .. PillState.craftInterval .. "秒"
    intervalLabel.TextColor3 = Color3.fromRGB(200, 255, 200)
    intervalLabel.Font = Enum.Font.SourceSansBold
    intervalLabel.TextSize = UI.BODY_TEXT_SIZE
    intervalLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 炼制间隔输入框
    local intervalFrame = Instance.new("Frame")
    intervalFrame.Name = "IntervalFrame"
    intervalFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, UI.BUTTON_HEIGHT)
    intervalFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 235)
    intervalFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    intervalFrame.BorderSizePixel = 0
    
    local intervalTextBox = Instance.new("TextBox")
    intervalTextBox.Name = "IntervalTextBox"
    intervalTextBox.Size = UDim2.new(0.7, 0, 1, 0)
    intervalTextBox.Position = UDim2.new(0, 0, 0, 0)
    intervalTextBox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
    intervalTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    intervalTextBox.Font = Enum.Font.SourceSans
    intervalTextBox.Text = tostring(PillState.craftInterval)
    intervalTextBox.TextSize = UI.BUTTON_TEXT_SIZE
    intervalTextBox.BorderSizePixel = 0
    intervalTextBox.PlaceholderText = "输入炼药间隔秒数 (1-60)"
    
    local intervalApplyButton = Instance.new("TextButton")
    intervalApplyButton.Name = "IntervalApplyButton"
    intervalApplyButton.Size = UDim2.new(0.3, 0, 1, 0)
    intervalApplyButton.Position = UDim2.new(0.7, 0, 0, 0)
    intervalApplyButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    intervalApplyButton.Text = "应用"
    intervalApplyButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    intervalApplyButton.Font = Enum.Font.SourceSansBold
    intervalApplyButton.TextSize = UI.BUTTON_TEXT_SIZE
    intervalApplyButton.BorderSizePixel = 0
    
    -- 丹药列表区域
    local pillsFrame = Instance.new("Frame")
    pillsFrame.Name = "PillsFrame"
    pillsFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 200)
    pillsFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 280)
    pillsFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    pillsFrame.BorderSizePixel = 0
    
    local pillsTitle = Instance.new("TextLabel")
    pillsTitle.Name = "PillsTitle"
    pillsTitle.Size = UDim2.new(1, 0, 0, 25)
    pillsTitle.Position = UDim2.new(0, 0, 0, 0)
    pillsTitle.BackgroundColor3 = Color3.fromRGB(70, 70, 100)
    pillsTitle.Text = "丹药列表 (点击选择)"
    pillsTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    pillsTitle.Font = Enum.Font.SourceSansBold
    pillsTitle.TextSize = UI.BODY_TEXT_SIZE
    pillsTitle.BorderSizePixel = 0
    
    local pillsScroll = Instance.new("ScrollingFrame")
    pillsScroll.Name = "PillsScroll"
    pillsScroll.Size = UDim2.new(1, 0, 1, -25)
    pillsScroll.Position = UDim2.new(0, 0, 0, 25)
    pillsScroll.BackgroundTransparency = 1
    pillsScroll.BorderSizePixel = 0
    pillsScroll.ScrollBarThickness = 8
    pillsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
    
    -- 按钮区域
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Name = "ButtonFrame"
    buttonFrame.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 50)
    buttonFrame.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 485)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.BorderSizePixel = 0
    
    -- 开始炼药按钮
    local startButton = Instance.new("TextButton")
    startButton.Name = "StartButton"
    startButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    startButton.Position = UDim2.new(0.025, 0, 0, 5)
    startButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    startButton.Text = "开始炼药"
    startButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    startButton.Font = Enum.Font.SourceSansBold
    startButton.TextSize = UI.BUTTON_TEXT_SIZE
    startButton.BorderSizePixel = 0
    
    -- 单次炼药按钮
    local onceButton = Instance.new("TextButton")
    onceButton.Name = "OnceButton"
    onceButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    onceButton.Position = UDim2.new(0.525, 0, 0, 5)
    onceButton.BackgroundColor3 = Color3.fromRGB(150, 150, 50)
    onceButton.Text = "单次炼药"
    onceButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    onceButton.Font = Enum.Font.SourceSans
    onceButton.TextSize = UI.BUTTON_TEXT_SIZE
    onceButton.BorderSizePixel = 0
    
    -- 关闭按钮
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0.45, 0, 0, 28)
    closeButton.Position = UDim2.new(0.275, 0, 0, UI.BUTTON_HEIGHT + 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    closeButton.Text = "关闭"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.SourceSans
    closeButton.TextSize = UI.SMALL_TEXT_SIZE
    closeButton.BorderSizePixel = 0
    
    -- 创建丹药列表
    local function createPillList()
        for i, pillType in ipairs(CONFIG.PILL_TYPES) do
            local itemFrame = Instance.new("TextButton")
            itemFrame.Name = "PillItem_" .. i
            itemFrame.Size = UDim2.new(1, -10, 0, UI.HERB_ITEM_HEIGHT)
            itemFrame.Position = UDim2.new(0, 5, 0, (i-1) * (UI.HERB_ITEM_HEIGHT + 2))
            itemFrame.BackgroundColor3 = pillType == PillState.currentPillType and Color3.fromRGB(80, 120, 80) or Color3.fromRGB(60, 60, 80)
            itemFrame.Text = ""
            itemFrame.BorderSizePixel = 0
            
            local layout = Instance.new("UIListLayout")
            layout.FillDirection = Enum.FillDirection.Horizontal
            layout.HorizontalAlignment = Enum.HorizontalAlignment.Left
            layout.VerticalAlignment = Enum.VerticalAlignment.Center
            layout.SortOrder = Enum.SortOrder.LayoutOrder
            layout.Padding = UDim.new(0, 8)
            layout.Parent = itemFrame
            
            local checkbox = Instance.new("Frame")
            checkbox.Name = "Checkbox"
            checkbox.Size = UDim2.new(0, 24, 0, 24)
            checkbox.LayoutOrder = 1
            checkbox.BackgroundColor3 = pillType == PillState.currentPillType and Color3.fromRGB(100, 150, 100) or Color3.fromRGB(80, 80, 100)
            checkbox.BorderSizePixel = 0
            
            local checkmark = Instance.new("TextLabel")
            checkmark.Name = "Checkmark"
            checkmark.Size = UDim2.new(1, 0, 1, 0)
            checkmark.Position = UDim2.new(0, 0, 0, 0)
            checkmark.BackgroundTransparency = 1
            checkmark.Text = "✓"
            checkmark.TextColor3 = Color3.fromRGB(100, 255, 100)
            checkmark.Font = Enum.Font.SourceSansBold
            checkmark.TextSize = 18
            checkmark.Visible = pillType == PillState.currentPillType
            
            local nameLabel = Instance.new("TextLabel")
            nameLabel.Name = "Name"
            nameLabel.Size = UDim2.new(1, -30, 1, 0)
            nameLabel.LayoutOrder = 2
            nameLabel.BackgroundTransparency = 1
            nameLabel.Text = pillType
            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            nameLabel.Font = Enum.Font.SourceSans
            nameLabel.TextSize = UI.BODY_TEXT_SIZE
            nameLabel.TextXAlignment = Enum.TextXAlignment.Left
            nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
            
            itemFrame.MouseButton1Click:Connect(function()
                PillState.currentPillType = pillType
                currentSelectionLabel.Text = "当前选择: " .. pillType
                
                -- 更新所有项目的选择状态
                for _, child in ipairs(pillsScroll:GetChildren()) do
                    if child:IsA("TextButton") then
                        local childNameLabel = child:FindFirstChild("Name")
                        if childNameLabel then
                            if childNameLabel.Text == pillType then
                                child.BackgroundColor3 = Color3.fromRGB(80, 120, 80)
                                local checkbox = child:FindFirstChild("Checkbox")
                                if checkbox then
                                    checkbox.BackgroundColor3 = Color3.fromRGB(100, 150, 100)
                                    local checkmark = checkbox:FindFirstChild("Checkmark")
                                    if checkmark then
                                        checkmark.Visible = true
                                    end
                                end
                            else
                                child.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
                                local checkbox = child:FindFirstChild("Checkbox")
                                if checkbox then
                                    checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 100)
                                    local checkmark = checkbox:FindFirstChild("Checkmark")
                                    if checkmark then
                                        checkmark.Visible = false
                                    end
                                end
                            end
                        end
                    end
                end
                
                print("[炼药] 选择丹药: " .. pillType)
            end)
            
            checkmark.Parent = checkbox
            checkbox.Parent = itemFrame
            nameLabel.Parent = itemFrame
            itemFrame.Parent = pillsScroll
        end
        
        -- 更新滚动区域大小
        pillsScroll.CanvasSize = UDim2.new(0, 0, 0, #CONFIG.PILL_TYPES * (UI.HERB_ITEM_HEIGHT + 2))
    end
    
    -- 创建丹药列表
    createPillList()
    
    -- 炼制次数应用按钮事件
    countApplyButton.MouseButton1Click:Connect(function()
        local count = tonumber(countTextBox.Text) or 1
        count = math.max(1, math.min(1000, count)) -- 限制1-1000次
        PillState.craftCount = count
        countTextBox.Text = tostring(count)
        countLabel.Text = "炼制次数: " .. count
        print("[炼药] 设置炼制次数: " .. count)
    end)
    
    -- 炼制次数输入框事件
    countTextBox.FocusLost:Connect(function()
        local count = tonumber(countTextBox.Text) or 1
        count = math.max(1, math.min(1000, count)) -- 限制1-1000次
        PillState.craftCount = count
        countTextBox.Text = tostring(count)
        countLabel.Text = "炼制次数: " .. count
        print("[炼药] 设置炼制次数: " .. count)
    end)
    
    -- 炼药间隔应用按钮事件
    intervalApplyButton.MouseButton1Click:Connect(function()
        local interval = tonumber(intervalTextBox.Text) or 3
        interval = math.max(0.5, math.min(60, interval)) -- 限制1-60秒
        PillState.craftInterval = interval
        intervalTextBox.Text = tostring(interval)
        intervalLabel.Text = "炼药间隔: " .. interval .. "秒"
        print("[炼药] 设置炼药间隔: " .. interval .. "秒")
    end)
    
    -- 炼药间隔输入框事件
    intervalTextBox.FocusLost:Connect(function()
        local interval = tonumber(intervalTextBox.Text) or 3
        interval = math.max(0.5, math.min(60, interval)) -- 限制1-60秒
        PillState.craftInterval = interval
        intervalTextBox.Text = tostring(interval)
        intervalLabel.Text = "炼药间隔: " .. interval .. "秒"
        print("[炼药] 设置炼药间隔: " .. interval .. "秒")
    end)
    
    -- 开始炼药按钮事件
    startButton.MouseButton1Click:Connect(function()
        local count = tonumber(countTextBox.Text) or 1
        local interval = tonumber(intervalTextBox.Text) or 3
        
        count = math.max(1, math.min(1000, count)) -- 限制1-1000次
        interval = math.max(0.5, math.min(60, interval)) -- 限制1-60秒
        
        PillState.craftCount = count
        PillState.craftInterval = interval
        
        if startCraftPills(PillState.currentPillType, count) then
            print("[炼药] 开始批量炼药")
            screenGui:Destroy()
            PillUI = nil
            PillState.isPillUIOpen = false
        end
    end)
    
    -- 单次炼药按钮事件
    onceButton.MouseButton1Click:Connect(function()
        if craftSinglePill(PillState.currentPillType) then
            print("[炼药] 单次炼药完成")
            screenGui:Destroy()
            PillUI = nil
            PillState.isPillUIOpen = false
        end
    end)
    
    -- 关闭按钮事件
    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
        PillUI = nil
        PillState.isPillUIOpen = false
        print("[炼药] 关闭炼药设置")
    end)
    
    -- 关闭事件
    screenGui.Destroying:Connect(function()
        PillState.isPillUIOpen = false
        PillUI = nil
    end)
    
    -- 组装UI
    titleLabel.Parent = mainFrame
    instructionLabel.Parent = mainFrame
    currentSelectionLabel.Parent = mainFrame
    countLabel.Parent = mainFrame
    countFrame.Parent = mainFrame
    intervalLabel.Parent = mainFrame
    intervalFrame.Parent = mainFrame
    pillsFrame.Parent = mainFrame
    
    countTextBox.Parent = countFrame
    countApplyButton.Parent = countFrame
    
    intervalTextBox.Parent = intervalFrame
    intervalApplyButton.Parent = intervalFrame
    
    pillsTitle.Parent = pillsFrame
    pillsScroll.Parent = pillsFrame
    
    startButton.Parent = buttonFrame
    onceButton.Parent = buttonFrame
    closeButton.Parent = buttonFrame
    buttonFrame.Parent = mainFrame
    
    mainFrame.Parent = screenGui
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    PillUI = screenGui
    PillState.isPillUIOpen = true
    
    return screenGui
end

-- ===================== 创建主UI（已移除新功能标签，功能并入草药系统） =====================
local MainUI = nil
local CurrentTab = "herb" -- 当前选中的标签
local UIUpdateConnection = nil

local function createMainUI()
    if MainUI then
        MainUI:Destroy()
        MainUI = nil
    end
    
    -- 停止旧的UI更新连接
    if UIUpdateConnection then
        UIUpdateConnection:Disconnect()
        UIUpdateConnection = nil
    end
    
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HerbCultivationUI"
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.DisplayOrder = 10
    screenGui.Enabled = true
    
    local UI = CONFIG.UI_SCALE
    
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, UI.MAIN_FRAME_WIDTH, 0, UI.MAIN_FRAME_HEIGHT)
    mainFrame.Position = UDim2.new(0.02, 0, 0.02, 0)
    mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    mainFrame.BackgroundTransparency = 0.1
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = true
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 35)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    titleLabel.Text = "多功能采集系统"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = UI.TITLE_TEXT_SIZE
    titleLabel.BorderSizePixel = 0
    
    -- 左侧标签区域
    local tabFrame = Instance.new("Frame")
    tabFrame.Name = "TabFrame"
    tabFrame.Size = UDim2.new(0, UI.TAB_BUTTON_WIDTH + UI.PADDING_SMALL*2, 1, -35)
    tabFrame.Position = UDim2.new(0, 0, 0, 35)
    tabFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 70)
    tabFrame.BorderSizePixel = 0
    
    -- 右侧内容区域
    local contentFrame = Instance.new("Frame")
    contentFrame.Name = "ContentFrame"
    contentFrame.Size = UDim2.new(1, -(UI.TAB_BUTTON_WIDTH + UI.PADDING_SMALL*2), 1, -35)
    contentFrame.Position = UDim2.new(0, UI.TAB_BUTTON_WIDTH + UI.PADDING_SMALL*2, 0, 35)
    contentFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 65)
    contentFrame.BorderSizePixel = 0
    
    -- 草药标签按钮
    local herbTabButton = Instance.new("TextButton")
    herbTabButton.Name = "HerbTabButton"
    herbTabButton.Size = UDim2.new(1, -UI.PADDING_SMALL*2, 0, UI.TAB_BUTTON_HEIGHT)
    herbTabButton.Position = UDim2.new(0, UI.PADDING_SMALL, 0, UI.PADDING_SMALL)
    herbTabButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
    herbTabButton.Text = "草药系统"
    herbTabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbTabButton.Font = Enum.Font.SourceSansBold
    herbTabButton.TextSize = UI.BODY_TEXT_SIZE
    herbTabButton.BorderSizePixel = 0
    
    -- 功法标签按钮
    local auraTabButton = Instance.new("TextButton")
    auraTabButton.Name = "AuraTabButton"
    auraTabButton.Size = UDim2.new(1, -UI.PADDING_SMALL*2, 0, UI.TAB_BUTTON_HEIGHT)
    auraTabButton.Position = UDim2.new(0, UI.PADDING_SMALL, 0, UI.TAB_BUTTON_HEIGHT + UI.PADDING_SMALL*2)
    auraTabButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
    auraTabButton.Text = "功法系统"
    auraTabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    auraTabButton.Font = Enum.Font.SourceSansBold
    auraTabButton.TextSize = UI.BODY_TEXT_SIZE
    auraTabButton.BorderSizePixel = 0
    
    -- 修炼标签按钮
    local cultTabButton = Instance.new("TextButton")
    cultTabButton.Name = "CultTabButton"
    cultTabButton.Size = UDim2.new(1, -UI.PADDING_SMALL*2, 0, UI.TAB_BUTTON_HEIGHT)
    cultTabButton.Position = UDim2.new(0, UI.PADDING_SMALL, 0, UI.TAB_BUTTON_HEIGHT*2 + UI.PADDING_SMALL*3)
    cultTabButton.BackgroundColor3 = Color3.fromRGB(60, 90, 60)
    cultTabButton.Text = "修炼系统"
    cultTabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cultTabButton.Font = Enum.Font.SourceSansBold
    cultTabButton.TextSize = UI.BODY_TEXT_SIZE
    cultTabButton.BorderSizePixel = 0
    
    -- 炼药标签按钮
    local pillTabButton = Instance.new("TextButton")
    pillTabButton.Name = "PillTabButton"
    pillTabButton.Size = UDim2.new(1, -UI.PADDING_SMALL*2, 0, UI.TAB_BUTTON_HEIGHT)
    pillTabButton.Position = UDim2.new(0, UI.PADDING_SMALL, 0, UI.TAB_BUTTON_HEIGHT*3 + UI.PADDING_SMALL*4)
    pillTabButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
    pillTabButton.Text = "炼药系统"
    pillTabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    pillTabButton.Font = Enum.Font.SourceSansBold
    pillTabButton.TextSize = UI.BODY_TEXT_SIZE
    pillTabButton.BorderSizePixel = 0
    
    -- 草药内容区域
    local herbContentFrame = Instance.new("Frame")
    herbContentFrame.Name = "HerbContentFrame"
    herbContentFrame.Size = UDim2.new(1, 0, 1, 0)
    herbContentFrame.Position = UDim2.new(0, 0, 0, 0)
    herbContentFrame.BackgroundTransparency = 1
    herbContentFrame.Visible = true
    
    -- 功法内容区域
    local auraContentFrame = Instance.new("Frame")
    auraContentFrame.Name = "AuraContentFrame"
    auraContentFrame.Size = UDim2.new(1, 0, 1, 0)
    auraContentFrame.Position = UDim2.new(0, 0, 0, 0)
    auraContentFrame.BackgroundTransparency = 1
    auraContentFrame.Visible = false
    
    -- 修炼内容区域
    local cultContentFrame = Instance.new("Frame")
    cultContentFrame.Name = "CultContentFrame"
    cultContentFrame.Size = UDim2.new(1, 0, 1, 0)
    cultContentFrame.Position = UDim2.new(0, 0, 0, 0)
    cultContentFrame.BackgroundTransparency = 1
    cultContentFrame.Visible = false
    
    -- 炼药内容区域
    local pillContentFrame = Instance.new("Frame")
    pillContentFrame.Name = "PillContentFrame"
    pillContentFrame.Size = UDim2.new(1, 0, 1, 0)
    pillContentFrame.Position = UDim2.new(0, 0, 0, 0)
    pillContentFrame.BackgroundTransparency = 1
    pillContentFrame.Visible = false
    
    -- ===================== 草药内容（已包含新功能） =====================
    local herbStatusLabel = Instance.new("TextLabel")
    herbStatusLabel.Name = "HerbStatusLabel"
    herbStatusLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    herbStatusLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 10)
    herbStatusLabel.BackgroundTransparency = 1
    herbStatusLabel.Text = "状态: 停止"
    herbStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    herbStatusLabel.Font = Enum.Font.SourceSans
    herbStatusLabel.TextSize = UI.SUBTITLE_TEXT_SIZE
    herbStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local herbTargetLabel = Instance.new("TextLabel")
    herbTargetLabel.Name = "HerbTargetLabel"
    herbTargetLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    herbTargetLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 40)
    herbTargetLabel.BackgroundTransparency = 1
    herbTargetLabel.Text = "当前目标: 无"
    herbTargetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    herbTargetLabel.Font = Enum.Font.SourceSans
    herbTargetLabel.TextSize = UI.SMALL_TEXT_SIZE
    herbTargetLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local herbPriorityLabel = Instance.new("TextLabel")
    herbPriorityLabel.Name = "HerbPriorityLabel"
    herbPriorityLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    herbPriorityLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 65)
    herbPriorityLabel.BackgroundTransparency = 1
    herbPriorityLabel.Text = #HerbState.priorityHerbs > 0 and string.format("优先级草药: %d种", #HerbState.priorityHerbs) or "优先级草药: 无 (采集所有草药)"
    herbPriorityLabel.TextColor3 = #HerbState.priorityHerbs > 0 and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(200, 200, 200)
    herbPriorityLabel.Font = Enum.Font.SourceSans
    herbPriorityLabel.TextSize = UI.SMALL_TEXT_SIZE
    herbPriorityLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local herbPriorityButton = Instance.new("TextButton")
    herbPriorityButton.Name = "HerbPriorityButton"
    herbPriorityButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbPriorityButton.Position = UDim2.new(0.025, 0, 0, 90)
    herbPriorityButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
    herbPriorityButton.Text = "设置优先级"
    herbPriorityButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbPriorityButton.Font = Enum.Font.SourceSansBold
    herbPriorityButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbPriorityButton.BorderSizePixel = 0
    
    local herbToggleButton = Instance.new("TextButton")
    herbToggleButton.Name = "HerbToggleButton"
    herbToggleButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbToggleButton.Position = UDim2.new(0.525, 0, 0, 90)
    herbToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    herbToggleButton.Text = "启动系统"
    herbToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbToggleButton.Font = Enum.Font.SourceSansBold
    herbToggleButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbToggleButton.BorderSizePixel = 0
    
    local herbResetButton = Instance.new("TextButton")
    herbResetButton.Name = "HerbResetButton"
    herbResetButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbResetButton.Position = UDim2.new(0.025, 0, 0, 135)
    herbResetButton.BackgroundColor3 = Color3.fromRGB(150, 150, 50)
    herbResetButton.Text = "重置状态"
    herbResetButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbResetButton.Font = Enum.Font.SourceSans
    herbResetButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbResetButton.BorderSizePixel = 0
    
    -- 新增：一键加速按钮
    local herbQuickPickButton = Instance.new("TextButton")
    herbQuickPickButton.Name = "HerbQuickPickButton"
    herbQuickPickButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbQuickPickButton.Position = UDim2.new(0.525, 0, 0, 135)
    herbQuickPickButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
    herbQuickPickButton.Text = "一键加速"
    herbQuickPickButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbQuickPickButton.Font = Enum.Font.SourceSansBold
    herbQuickPickButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbQuickPickButton.BorderSizePixel = 0
    
    -- 新增：自动采摘按钮
    local herbAutoHarvestButton = Instance.new("TextButton")
    herbAutoHarvestButton.Name = "HerbAutoHarvestButton"
    herbAutoHarvestButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbAutoHarvestButton.Position = UDim2.new(0.025, 0, 0, 180)
    herbAutoHarvestButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
    herbAutoHarvestButton.Text = "自动采摘"
    herbAutoHarvestButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbAutoHarvestButton.Font = Enum.Font.SourceSansBold
    herbAutoHarvestButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbAutoHarvestButton.BorderSizePixel = 0
    
    -- 新增：功法自动收集按钮（已移到草药系统）
    local herbAuraAutoCollectButton = Instance.new("TextButton")
    herbAuraAutoCollectButton.Name = "HerbAuraAutoCollectButton"
    herbAuraAutoCollectButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbAuraAutoCollectButton.Position = UDim2.new(0.525, 0, 0, 180)
    herbAuraAutoCollectButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
    herbAuraAutoCollectButton.Text = "功法自动收集"
    herbAuraAutoCollectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbAuraAutoCollectButton.Font = Enum.Font.SourceSansBold
    herbAuraAutoCollectButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbAuraAutoCollectButton.BorderSizePixel = 0
    
    -- 新增：禁用地图碰撞按钮
    local herbCollisionButton = Instance.new("TextButton")
    herbCollisionButton.Name = "HerbCollisionButton"
    herbCollisionButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    herbCollisionButton.Position = UDim2.new(0.025, 0, 0, 225)
    herbCollisionButton.BackgroundColor3 = Color3.fromRGB(120, 70, 150)
    herbCollisionButton.Text = "禁用地图碰撞"
    herbCollisionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    herbCollisionButton.Font = Enum.Font.SourceSansBold
    herbCollisionButton.TextSize = UI.BUTTON_TEXT_SIZE
    herbCollisionButton.BorderSizePixel = 0
    
    local herbInfoLabel = Instance.new("TextLabel")
    herbInfoLabel.Name = "HerbInfoLabel"
    herbInfoLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 100)
    herbInfoLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 1, -110)
    herbInfoLabel.BackgroundTransparency = 1
    herbInfoLabel.Text = "提示: 自动寻找并采集草药\n支持优先级草药设置\n一键加速: 开启后秒采草药\n自动采摘: 靠近草药自动采集\n功法自动收集: 自动收集附近的功法\n禁用地图碰撞: 关闭Map文件夹中所有部件的碰撞"
    herbInfoLabel.TextColor3 = Color3.fromRGB(180, 180, 255)
    herbInfoLabel.Font = Enum.Font.SourceSans
    herbInfoLabel.TextSize = UI.SMALL_TEXT_SIZE
    herbInfoLabel.TextWrapped = true
    herbInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- ===================== 功法内容 =====================
    local auraStatusLabel = Instance.new("TextLabel")
    auraStatusLabel.Name = "AuraStatusLabel"
    auraStatusLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    auraStatusLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 10)
    auraStatusLabel.BackgroundTransparency = 1
    auraStatusLabel.Text = "功法采集: 已启用"
    auraStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    auraStatusLabel.Font = Enum.Font.SourceSans
    auraStatusLabel.TextSize = UI.SUBTITLE_TEXT_SIZE
    auraStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local auraTargetLabel = Instance.new("TextLabel")
    auraTargetLabel.Name = "AuraTargetLabel"
    auraTargetLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    auraTargetLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 40)
    auraTargetLabel.BackgroundTransparency = 1
    auraTargetLabel.Text = "当前功法: 无"
    auraTargetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    auraTargetLabel.Font = Enum.Font.SourceSans
    auraTargetLabel.TextSize = UI.SMALL_TEXT_SIZE
    auraTargetLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local auraModeLabel = Instance.new("TextLabel")
    auraModeLabel.Name = "AuraModeLabel"
    auraModeLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    auraModeLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 65)
    auraModeLabel.BackgroundTransparency = 1
    auraModeLabel.Text = "目标模式: 两者优先"
    auraModeLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    auraModeLabel.Font = Enum.Font.SourceSans
    auraModeLabel.TextSize = UI.SMALL_TEXT_SIZE
    auraModeLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local auraModeButton = Instance.new("TextButton")
    auraModeButton.Name = "AuraModeButton"
    auraModeButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    auraModeButton.Position = UDim2.new(0.025, 0, 0, 90)
    auraModeButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
    auraModeButton.Text = "切换模式"
    auraModeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    auraModeButton.Font = Enum.Font.SourceSansBold
    auraModeButton.TextSize = UI.BUTTON_TEXT_SIZE
    auraModeButton.BorderSizePixel = 0
    
    local auraInfoLabel = Instance.new("TextLabel")
    auraInfoLabel.Name = "AuraInfoLabel"
    auraInfoLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 80)
    auraInfoLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 1, -90)
    auraInfoLabel.BackgroundTransparency = 1
    auraInfoLabel.Text = "提示: 功法采集系统自动寻找并采集功法\n目标模式:\n- 两者优先: 优先功法，其次草药\n- 仅功法: 只采集功法\n- 仅草药: 只采集草药\n注意: 功法自动收集功能已移至草药系统标签"
    auraInfoLabel.TextColor3 = Color3.fromRGB(180, 180, 255)
    auraInfoLabel.Font = Enum.Font.SourceSans
    auraInfoLabel.TextSize = UI.SMALL_TEXT_SIZE
    auraInfoLabel.TextWrapped = true
    auraInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- ===================== 修炼内容 =====================
    local cultStatusLabel = Instance.new("TextLabel")
    cultStatusLabel.Name = "CultStatusLabel"
    cultStatusLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    cultStatusLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 10)
    cultStatusLabel.BackgroundTransparency = 1
    cultStatusLabel.Text = "修炼状态: 未修炼"
    cultStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    cultStatusLabel.Font = Enum.Font.SourceSans
    cultStatusLabel.TextSize = UI.SUBTITLE_TEXT_SIZE
    cultStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local cultBreakthroughLabel = Instance.new("TextLabel")
    cultBreakthroughLabel.Name = "CultBreakthroughLabel"
    cultBreakthroughLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    cultBreakthroughLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 40)
    cultBreakthroughLabel.BackgroundTransparency = 1
    cultBreakthroughLabel.Text = "自动突破: 关闭"
    cultBreakthroughLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    cultBreakthroughLabel.Font = Enum.Font.SourceSans
    cultBreakthroughLabel.TextSize = UI.SUBTITLE_TEXT_SIZE
    cultBreakthroughLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local cultToggleButton = Instance.new("TextButton")
    cultToggleButton.Name = "CultToggleButton"
    cultToggleButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    cultToggleButton.Position = UDim2.new(0.025, 0, 0, 75)
    cultToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    cultToggleButton.Text = "开始修炼"
    cultToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cultToggleButton.Font = Enum.Font.SourceSansBold
    cultToggleButton.TextSize = UI.BUTTON_TEXT_SIZE
    cultToggleButton.BorderSizePixel = 0
    
    local cultBreakthroughButton = Instance.new("TextButton")
    cultBreakthroughButton.Name = "CultBreakthroughButton"
    cultBreakthroughButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    cultBreakthroughButton.Position = UDim2.new(0.525, 0, 0, 75)
    cultBreakthroughButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
    cultBreakthroughButton.Text = "开启突破"
    cultBreakthroughButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cultBreakthroughButton.Font = Enum.Font.SourceSansBold
    cultBreakthroughButton.TextSize = UI.BUTTON_TEXT_SIZE
    cultBreakthroughButton.BorderSizePixel = 0
    
    local cultOnceButton = Instance.new("TextButton")
    cultOnceButton.Name = "CultOnceButton"
    cultOnceButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    cultOnceButton.Position = UDim2.new(0.025, 0, 0, 120)
    cultOnceButton.BackgroundColor3 = Color3.fromRGB(150, 150, 50)
    cultOnceButton.Text = "单次突破"
    cultOnceButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cultOnceButton.Font = Enum.Font.SourceSans
    cultOnceButton.TextSize = UI.BUTTON_TEXT_SIZE
    cultOnceButton.BorderSizePixel = 0
    
    local cultInfoLabel = Instance.new("TextLabel")
    cultInfoLabel.Name = "CultInfoLabel"
    cultInfoLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 50)
    cultInfoLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 1, -60)
    cultInfoLabel.BackgroundTransparency = 1
    cultInfoLabel.Text = "提示: 修炼状态可自动突破\n每隔" .. CONFIG.BREAKTHROUGH_INTERVAL .. "秒自动突破一次"
    cultInfoLabel.TextColor3 = Color3.fromRGB(180, 180, 255)
    cultInfoLabel.Font = Enum.Font.SourceSans
    cultInfoLabel.TextSize = UI.SMALL_TEXT_SIZE
    cultInfoLabel.TextWrapped = true
    cultInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- ===================== 炼药内容 =====================
    local pillStatusLabel = Instance.new("TextLabel")
    pillStatusLabel.Name = "PillStatusLabel"
    pillStatusLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 25)
    pillStatusLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 10)
    pillStatusLabel.BackgroundTransparency = 1
    pillStatusLabel.Text = "炼药状态: 未运行"
    pillStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
    pillStatusLabel.Font = Enum.Font.SourceSans
    pillStatusLabel.TextSize = UI.SUBTITLE_TEXT_SIZE
    pillStatusLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local pillTypeLabel = Instance.new("TextLabel")
    pillTypeLabel.Name = "PillTypeLabel"
    pillTypeLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    pillTypeLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 40)
    pillTypeLabel.BackgroundTransparency = 1
    pillTypeLabel.Text = "当前丹药: Qi Spirit"
    pillTypeLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    pillTypeLabel.Font = Enum.Font.SourceSans
    pillTypeLabel.TextSize = UI.SMALL_TEXT_SIZE
    pillTypeLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local pillCountLabel = Instance.new("TextLabel")
    pillCountLabel.Name = "PillCountLabel"
    pillCountLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 20)
    pillCountLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 0, 65)
    pillCountLabel.BackgroundTransparency = 1
    pillCountLabel.Text = "默认次数: 1"
    pillCountLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
    pillCountLabel.Font = Enum.Font.SourceSans
    pillCountLabel.TextSize = UI.SMALL_TEXT_SIZE
    pillCountLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    local pillSettingButton = Instance.new("TextButton")
    pillSettingButton.Name = "PillSettingButton"
    pillSettingButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    pillSettingButton.Position = UDim2.new(0.025, 0, 0, 90)
    pillSettingButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
    pillSettingButton.Text = "炼药设置"
    pillSettingButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    pillSettingButton.Font = Enum.Font.SourceSansBold
    pillSettingButton.TextSize = UI.BUTTON_TEXT_SIZE
    pillSettingButton.BorderSizePixel = 0
    
    local pillToggleButton = Instance.new("TextButton")
    pillToggleButton.Name = "PillToggleButton"
    pillToggleButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    pillToggleButton.Position = UDim2.new(0.525, 0, 0, 90)
    pillToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    pillToggleButton.Text = "开始炼药"
    pillToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    pillToggleButton.Font = Enum.Font.SourceSansBold
    pillToggleButton.TextSize = UI.BUTTON_TEXT_SIZE
    pillToggleButton.BorderSizePixel = 0
    
    local pillOnceButton = Instance.new("TextButton")
    pillOnceButton.Name = "PillOnceButton"
    pillOnceButton.Size = UDim2.new(0.45, 0, 0, UI.BUTTON_HEIGHT)
    pillOnceButton.Position = UDim2.new(0.025, 0, 0, 135)
    pillOnceButton.BackgroundColor3 = Color3.fromRGB(150, 150, 50)
    pillOnceButton.Text = "单次炼药"
    pillOnceButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    pillOnceButton.Font = Enum.Font.SourceSans
    pillOnceButton.TextSize = UI.BUTTON_TEXT_SIZE
    pillOnceButton.BorderSizePixel = 0
    
    local pillInfoLabel = Instance.new("TextLabel")
    pillInfoLabel.Name = "PillInfoLabel"
    pillInfoLabel.Size = UDim2.new(1, -UI.PADDING_MEDIUM*2, 0, 60)
    pillInfoLabel.Position = UDim2.new(0, UI.PADDING_MEDIUM, 1, -70)
    pillInfoLabel.BackgroundTransparency = 1
    pillInfoLabel.Text = "提示: 使用炼药设置选择丹药类型和次数\n点击开始炼药进行批量炼制\n单次炼药只炼制一次"
    pillInfoLabel.TextColor3 = Color3.fromRGB(180, 180, 255)
    pillInfoLabel.Font = Enum.Font.SourceSans
    pillInfoLabel.TextSize = UI.SMALL_TEXT_SIZE
    pillInfoLabel.TextWrapped = true
    pillInfoLabel.TextXAlignment = Enum.TextXAlignment.Left
    
    -- 标签按钮事件
    local function switchTab(tabName)
        CurrentTab = tabName
        
        -- 重置所有标签按钮颜色
        herbTabButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
        auraTabButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
        cultTabButton.BackgroundColor3 = Color3.fromRGB(60, 90, 60)
        pillTabButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
        
        -- 隐藏所有内容区域
        herbContentFrame.Visible = false
        auraContentFrame.Visible = false
        cultContentFrame.Visible = false
        pillContentFrame.Visible = false
        
        -- 显示选中的内容区域
        if tabName == "herb" then
            herbTabButton.BackgroundColor3 = Color3.fromRGB(90, 90, 170)
            herbContentFrame.Visible = true
        elseif tabName == "aura" then
            auraTabButton.BackgroundColor3 = Color3.fromRGB(180, 130, 80)
            auraContentFrame.Visible = true
        elseif tabName == "cult" then
            cultTabButton.BackgroundColor3 = Color3.fromRGB(80, 120, 80)
            cultContentFrame.Visible = true
        elseif tabName == "pill" then
            pillTabButton.BackgroundColor3 = Color3.fromRGB(180, 80, 80)
            pillContentFrame.Visible = true
        end
    end
    
    herbTabButton.MouseButton1Click:Connect(function()
        switchTab("herb")
    end)
    
    auraTabButton.MouseButton1Click:Connect(function()
        switchTab("aura")
    end)
    
    cultTabButton.MouseButton1Click:Connect(function()
        switchTab("cult")
    end)
    
    pillTabButton.MouseButton1Click:Connect(function()
        switchTab("pill")
    end)
    
    -- 草药按钮事件
    herbPriorityButton.MouseButton1Click:Connect(function()
        print("[UI] 打开优先级选择界面")
        createPrioritySelectionUI()
    end)
    
    herbToggleButton.MouseButton1Click:Connect(function()
        if HerbState.isPriorityUIOpen then
            print("[UI] 请先关闭优先级选择界面")
            return
        end
        
        if HerbState.isRunning then
            stopHerbSystem()
        else
            -- 修复：启动系统时不强制改变目标模式
            startHerbSystem()
        end
    end)
    
    herbResetButton.MouseButton1Click:Connect(function()
        print("[UI] 重置扫描状态")
        resetScanState()
    end)
    
    -- 一键加速按钮事件
    herbQuickPickButton.MouseButton1Click:Connect(function()
        local enabled = toggleQuickPick()
        if enabled then
            herbQuickPickButton.Text = "关闭加速"
            herbQuickPickButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
        else
            herbQuickPickButton.Text = "一键加速"
            herbQuickPickButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
        end
    end)
    
    -- 自动采摘按钮事件
    herbAutoHarvestButton.MouseButton1Click:Connect(function()
        local enabled = toggleAutoHarvest()
        if enabled then
            herbAutoHarvestButton.Text = "关闭自动"
            herbAutoHarvestButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        else
            herbAutoHarvestButton.Text = "自动采摘"
            herbAutoHarvestButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
        end
    end)
    
    -- 功法自动收集按钮事件
    herbAuraAutoCollectButton.MouseButton1Click:Connect(function()
        local enabled = toggleAuraAutoCollect()
        if enabled then
            herbAuraAutoCollectButton.Text = "关闭功法自动"
            herbAuraAutoCollectButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        else
            herbAuraAutoCollectButton.Text = "功法自动收集"
            herbAuraAutoCollectButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
        end
    end)
    
    -- 禁用地图碰撞按钮事件
    herbCollisionButton.MouseButton1Click:Connect(function()
        if CollisionState.isCollisionDisabled then
            print("[UI] 开始恢复地图碰撞...")
            local success = enableAllCollisionInMap()
            if success then
                herbCollisionButton.Text = "禁用地图碰撞"
                herbCollisionButton.BackgroundColor3 = Color3.fromRGB(120, 70, 150)
            end
        else
            print("[UI] 开始禁用Map文件夹中的所有碰撞属性")
            local success = disableAllCollisionInMap()
            if success then
                herbCollisionButton.Text = "已禁用碰撞"
                herbCollisionButton.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
            else
                herbCollisionButton.Text = "操作失败"
                herbCollisionButton.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
                
                -- 3秒后恢复按钮文本
                task.delay(3, function()
                    if herbCollisionButton then
                        herbCollisionButton.Text = "禁用地图碰撞"
                        herbCollisionButton.BackgroundColor3 = Color3.fromRGB(120, 70, 150)
                    end
                end)
            end
        end
    end)
    
    -- 功法按钮事件
    auraModeButton.MouseButton1Click:Connect(function()
        -- 切换目标模式
        if HerbState.targetMode == "both" then
            HerbState.targetMode = "aura"
            auraModeLabel.Text = "目标模式: 仅功法"
            print("[功法] 切换为仅采集功法模式")
        elseif HerbState.targetMode == "aura" then
            HerbState.targetMode = "herb"
            auraModeLabel.Text = "目标模式: 仅草药"
            print("[功法] 切换为仅采集草药模式")
        else
            HerbState.targetMode = "both"
            auraModeLabel.Text = "目标模式: 两者优先"
            print("[功法] 切换为两者优先模式")
        end
    end)
    
    -- 修炼按钮事件
    cultToggleButton.MouseButton1Click:Connect(function()
        local newState = toggleCultivation()
        
        if newState then
            cultStatusLabel.Text = "修炼状态: 修炼中"
            cultStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            cultToggleButton.Text = "停止修炼"
            cultToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
        else
            cultStatusLabel.Text = "修炼状态: 未修炼"
            cultStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            cultToggleButton.Text = "开始修炼"
            cultToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
            
            if CultState.isAutoBreakthrough then
                stopAutoBreakthrough()
            end
        end
    end)
    
    cultBreakthroughButton.MouseButton1Click:Connect(function()
        if not CultState.isCultivating then
            print("[突破] 请先开始修炼")
            return
        end
        
        if CultState.isAutoBreakthrough then
            stopAutoBreakthrough()
            cultBreakthroughLabel.Text = "自动突破: 关闭"
            cultBreakthroughLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            cultBreakthroughButton.Text = "开启突破"
            cultBreakthroughButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        else
            startAutoBreakthrough()
            cultBreakthroughLabel.Text = "自动突破: 开启"
            cultBreakthroughLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
            cultBreakthroughButton.Text = "关闭突破"
            cultBreakthroughButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
        end
    end)
    
    cultOnceButton.MouseButton1Click:Connect(function()
        if not CultState.isCultivating then
            print("[突破] 请先开始修炼")
            return
        end
        
        breakthroughOnce()
    end)
    
    -- 炼药按钮事件
    pillSettingButton.MouseButton1Click:Connect(function()
        print("[UI] 打开炼药设置界面")
        createPillUI()
    end)
    
    pillToggleButton.MouseButton1Click:Connect(function()
        if PillState.isPillUIOpen then
            print("[UI] 请先关闭炼药设置界面")
            return
        end
        
        if PillState.isCrafting then
            stopCraftPills()
            pillStatusLabel.Text = "炼药状态: 未运行"
            pillStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            pillToggleButton.Text = "开始炼药"
            pillToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
        else
            -- 使用默认次数1
            if startCraftPills(PillState.currentPillType, PillState.craftCount) then
                pillStatusLabel.Text = "炼药状态: 运行中"
                pillStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                pillToggleButton.Text = "停止炼药"
                pillToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
            else
                pillStatusLabel.Text = "炼药状态: 启动失败"
                pillStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
            end
        end
    end)
    
    pillOnceButton.MouseButton1Click:Connect(function()
        if PillState.isPillUIOpen then
            print("[UI] 请先关闭炼药设置界面")
            return
        end
        
        craftSinglePill(PillState.currentPillType)
    end)
    
    -- 组装UI
    titleLabel.Parent = mainFrame
    tabFrame.Parent = mainFrame
    contentFrame.Parent = mainFrame
    
    herbTabButton.Parent = tabFrame
    auraTabButton.Parent = tabFrame
    cultTabButton.Parent = tabFrame
    pillTabButton.Parent = tabFrame
    
    herbContentFrame.Parent = contentFrame
    auraContentFrame.Parent = contentFrame
    cultContentFrame.Parent = contentFrame
    pillContentFrame.Parent = contentFrame
    
    herbStatusLabel.Parent = herbContentFrame
    herbTargetLabel.Parent = herbContentFrame
    herbPriorityLabel.Parent = herbContentFrame
    herbPriorityButton.Parent = herbContentFrame
    herbToggleButton.Parent = herbContentFrame
    herbResetButton.Parent = herbContentFrame
    herbQuickPickButton.Parent = herbContentFrame
    herbAutoHarvestButton.Parent = herbContentFrame
    herbAuraAutoCollectButton.Parent = herbContentFrame
    herbCollisionButton.Parent = herbContentFrame
    herbInfoLabel.Parent = herbContentFrame
    
    auraStatusLabel.Parent = auraContentFrame
    auraTargetLabel.Parent = auraContentFrame
    auraModeLabel.Parent = auraContentFrame
    auraModeButton.Parent = auraContentFrame
    auraInfoLabel.Parent = auraContentFrame
    
    cultStatusLabel.Parent = cultContentFrame
    cultBreakthroughLabel.Parent = cultContentFrame
    cultToggleButton.Parent = cultContentFrame
    cultBreakthroughButton.Parent = cultContentFrame
    cultOnceButton.Parent = cultContentFrame
    cultInfoLabel.Parent = cultContentFrame
    
    pillStatusLabel.Parent = pillContentFrame
    pillTypeLabel.Parent = pillContentFrame
    pillCountLabel.Parent = pillContentFrame
    pillSettingButton.Parent = pillContentFrame
    pillToggleButton.Parent = pillContentFrame
    pillOnceButton.Parent = pillContentFrame
    pillInfoLabel.Parent = pillContentFrame
    
    mainFrame.Parent = screenGui
    
    -- 移动设备适配
    if MobileToggleButton then
        MobileToggleButton.Visible = true
        MobileToggleButton.Text = "隐藏界面"
        MobileToggleButton.MouseButton1Click:Connect(function()
            screenGui.Enabled = not screenGui.Enabled
            MobileToggleButton.Text = screenGui.Enabled and "隐藏界面" or "打开界面"
            
            -- 关闭所有打开的UI
            if PriorityUI then
                PriorityUI:Destroy()
                PriorityUI = nil
                HerbState.isPriorityUIOpen = false
            end
            
            if PillUI then
                PillUI:Destroy()
                PillUI = nil
                PillState.isPillUIOpen = false
            end
        end)
    end
    
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    MainUI = screenGui
    
    -- 定期更新UI - 使用更稳定的方式
    UIUpdateConnection = RunService.Heartbeat:Connect(function()
        if screenGui and screenGui.Parent and screenGui.Enabled then
            -- 草药UI更新
            if herbStatusLabel then
                if HerbState.isRunning then
                    herbStatusLabel.Text = "状态: 运行中"
                    herbStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                    herbToggleButton.Text = "停止系统"
                    herbToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                else
                    herbStatusLabel.Text = "状态: 停止"
                    herbStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                    herbToggleButton.Text = "启动系统"
                    herbToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
                end
            end
            
            if herbTargetLabel then
                if HerbState.currentHerb and HerbState.currentHerb.Parent then
                    local age = getHerbAge(HerbState.currentHerb)
                    local priority = getHerbPriority(HerbState.currentHerb.Name)
                    local priorityText = priority and string.format(" [优先级%d]", priority) or ""
                    herbTargetLabel.Text = string.format("当前目标: %s (年份: %d)%s", HerbState.currentHerb.Name, age, priorityText)
                    herbTargetLabel.TextColor3 = priority and Color3.fromRGB(255, 215, 0) or Color3.fromRGB(100, 255, 100)
                elseif AuraState.currentAura and AuraState.currentAura.Parent then
                    herbTargetLabel.Text = string.format("当前功法: %s", AuraState.currentAura.Name)
                    herbTargetLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
                else
                    herbTargetLabel.Text = "当前目标: 无"
                    herbTargetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
                end
            end
            
            if herbPriorityLabel then
                if #HerbState.priorityHerbs > 0 then
                    herbPriorityLabel.Text = string.format("优先级草药: %d种", #HerbState.priorityHerbs)
                    herbPriorityLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                else
                    herbPriorityLabel.Text = "优先级草药: 无 (采集所有草药)"
                    herbPriorityLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                end
            end
            
            if herbQuickPickButton then
                if HerbState.quickPickEnabled then
                    herbQuickPickButton.Text = "关闭加速"
                    herbQuickPickButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
                else
                    herbQuickPickButton.Text = "一键加速"
                    herbQuickPickButton.BackgroundColor3 = Color3.fromRGB(70, 70, 150)
                end
            end
            
            if herbAutoHarvestButton then
                if HerbState.autoHarvestEnabled then
                    herbAutoHarvestButton.Text = "关闭自动"
                    herbAutoHarvestButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                else
                    herbAutoHarvestButton.Text = "自动采摘"
                    herbAutoHarvestButton.BackgroundColor3 = Color3.fromRGB(150, 70, 70)
                end
            end
            
            if herbAuraAutoCollectButton then
                if AuraAutoCollectState.enabled then
                    herbAuraAutoCollectButton.Text = "关闭功法自动"
                    herbAuraAutoCollectButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                else
                    herbAuraAutoCollectButton.Text = "功法自动收集"
                    herbAuraAutoCollectButton.BackgroundColor3 = Color3.fromRGB(150, 100, 70)
                end
            end
            
            -- 功法UI更新
            if auraTargetLabel then
                if AuraState.currentAura and AuraState.currentAura.Parent then
                    auraTargetLabel.Text = string.format("当前功法: %s", AuraState.currentAura.Name)
                    auraTargetLabel.TextColor3 = Color3.fromRGB(255, 215, 0)
                else
                    auraTargetLabel.Text = "当前功法: 无"
                    auraTargetLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
                end
            end
            
            if auraModeLabel then
                if HerbState.targetMode == "both" then
                    auraModeLabel.Text = "目标模式: 两者优先"
                elseif HerbState.targetMode == "aura" then
                    auraModeLabel.Text = "目标模式: 仅功法"
                else
                    auraModeLabel.Text = "目标模式: 仅草药"
                end
            end
            
            -- 修炼UI更新
            if cultStatusLabel then
                if CultState.isCultivating then
                    cultStatusLabel.Text = "修炼状态: 修炼中"
                    cultStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                    cultToggleButton.Text = "停止修炼"
                    cultToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                else
                    cultStatusLabel.Text = "修炼状态: 未修炼"
                    cultStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                    cultToggleButton.Text = "开始修炼"
                    cultToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
                end
            end
            
            if cultBreakthroughLabel then
                if CultState.isAutoBreakthrough then
                    cultBreakthroughLabel.Text = "自动突破: 开启"
                    cultBreakthroughLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                    cultBreakthroughButton.Text = "关闭突破"
                    cultBreakthroughButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
                else
                    cultBreakthroughLabel.Text = "自动突破: 关闭"
                    cultBreakthroughLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                    cultBreakthroughButton.Text = "开启突破"
                    cultBreakthroughButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
                end
            end
            
            -- 炼药UI更新
            if pillStatusLabel then
                if PillState.isCrafting then
                    pillStatusLabel.Text = "炼药状态: 运行中"
                    pillStatusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
                    pillToggleButton.Text = "停止炼药"
                    pillToggleButton.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                else
                    pillStatusLabel.Text = "炼药状态: 未运行"
                    pillStatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
                    pillToggleButton.Text = "开始炼药"
                    pillToggleButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
                end
            end
            
            if pillTypeLabel then
                pillTypeLabel.Text = "当前丹药: " .. PillState.currentPillType
            end
            
            if pillCountLabel then
                pillCountLabel.Text = "默认次数: " .. PillState.craftCount
            end
        end
    end)
    
    return screenGui
end

-- ===================== 主初始化 =====================
print("=== 多功能采集系统 ===")
print("版本: 完整功能修复版 + 地图碰撞禁用修复 + 防AFK")
print("主要功能:")
print("1. 草药系统: 优先级草药选择 + 一键加速 + 自动采摘 + 功法自动收集")
print("2. 功法系统: 修复下降问题，优化搜索")
print("3. 修炼系统: 自动突破 (间隔: " .. CONFIG.BREAKTHROUGH_INTERVAL .. "秒)")
print("4. 炼药系统: 独立设置界面 (支持 " .. #CONFIG.PILL_TYPES .. " 种丹药)")
print("5. 修复: 地图碰撞禁用 - 解决碰撞恢复问题")
print("6. 增强防AFK: 双策略防挂机 (模拟输入 + 远程信号)")

-- 启动防AFK系统
setupAntiAFK()
setupGameInputMonitoring()

-- 预加载草药类型
loadHerbTypesFromReplicatedStorage()

-- 创建移动端开关
createMobileToggle()

-- 创建主UI
createMainUI()

-- ===================== 启动防AFK系统 =====================
print("[防AFK] 启动防AFK系统")
setupAntiAFK()

-- ===================== 修复定期检查和自动重启机制 =====================
task.spawn(function()
    while true do
        task.wait(60) -- 每60秒检查一次所有系统状态
        
        -- 检查防AFK系统是否在运行
        if not AntiAFKState.isRunning or not AntiAFKState.connection then
            print("[系统检查] 防AFK系统停止，正在重新启动...")
            setupAntiAFK()
        end
        
        -- 检查碰撞状态（如果已启用）
        if CollisionState.isCollisionDisabled then
            -- 检查是否有部分对象的碰撞被恢复了
            local anyCollisionEnabled = false
            local restoredCount = 0
            
            for part, originalState in pairs(CollisionState.originalCollisionStates) do
                if part and part.Parent and part.CanCollide == true then
                    anyCollisionEnabled = true
                    restoredCount = restoredCount + 1
                    
                    -- 重新禁用碰撞
                    pcall(function()
                        part.CanCollide = false
                    end)
                end
            end
            
            if anyCollisionEnabled and restoredCount > 0 then
                print("[系统检查] 检测到 " .. restoredCount .. " 个对象碰撞被恢复，已重新禁用")
            end
        end
        
        -- 检查草药系统状态
        if HerbState.isRunning then
            -- 清理过期的缓存
            local currentTime = tick()
            for herb, cacheTime in pairs(HerbState.herbAgeCache) do
                if currentTime - cacheTime > 600 then -- 10分钟前的缓存
                    HerbState.herbAgeCache[herb] = nil
                end
            end
        end
    end
end)

-- ===================== 修复角色重生处理 =====================
local wasHerbRunningBeforeDeath = false
local wasAutoHarvestEnabled = false
local wasQuickPickEnabled = false
local wasAuraAutoCollectEnabled = false
local wasCultivating = false
local wasAutoBreakthrough = false
local wasCrafting = false
local wasCollisionDisabled = false
local currentTargetMode = "both" -- 保存当前目标模式

player.CharacterRemoving:Connect(function()
    print("[重生] 角色即将重生，记录当前状态...")
    
    -- 记录所有系统状态
    wasHerbRunningBeforeDeath = HerbState.isRunning
    wasAutoHarvestEnabled = HerbState.autoHarvestEnabled
    wasQuickPickEnabled = HerbState.quickPickEnabled
    wasAuraAutoCollectEnabled = AuraAutoCollectState.enabled
    wasCultivating = CultState.isCultivating
    wasAutoBreakthrough = CultState.isAutoBreakthrough
    wasCrafting = PillState.isCrafting
    wasCollisionDisabled = CollisionState.isCollisionDisabled
    currentTargetMode = HerbState.targetMode
    
    print("[重生] 状态记录完成:")
    print("- 草药系统: " .. tostring(wasHerbRunningBeforeDeath))
    print("- 自动采摘: " .. tostring(wasAutoHarvestEnabled))
    print("- 一键加速: " .. tostring(wasQuickPickEnabled))
    print("- 功法自动收集: " .. tostring(wasAuraAutoCollectEnabled))
    print("- 修炼状态: " .. tostring(wasCultivating))
    print("- 自动突破: " .. tostring(wasAutoBreakthrough))
    print("- 炼药状态: " .. tostring(wasCrafting))
    print("- 碰撞禁用: " .. tostring(wasCollisionDisabled))
    print("- 目标模式: " .. currentTargetMode)
    
    -- 注意：不要停止防AFK系统，让它继续运行
    print("[重生] 防AFK系统继续运行，不停止")
end)

player.CharacterAdded:Connect(function(newChar)
    print("[重生] 角色重生，重置所有状态")
    
    -- 更新角色引用
    character = newChar
    humanoid = newChar:WaitForChild("Humanoid")
    humanoidRootPart = newChar:WaitForChild("HumanoidRootPart")
    
    -- 停止所有系统
    stopHerbSystem()
    HerbState.currentHerb = nil
    AuraState.currentAura = nil
    HerbState.IsFlying = false
    StopAllMovement()
    
    -- 重置修炼状态
    if CultState.isCultivating then
        toggleCultivation()
    end
    if CultState.isAutoBreakthrough then
        stopAutoBreakthrough()
    end
    
    -- 重置炼药状态
    if PillState.isCrafting then
        stopCraftPills()
    end
    
    -- 重置自动采摘
    if HerbState.autoHarvestEnabled then
        toggleAutoHarvest()
    end
    
    -- 重置一键加速
    if HerbState.quickPickEnabled then
        toggleQuickPick()
    end
    
    -- 重置功法自动收集
    if AuraAutoCollectState.enabled then
        toggleAuraAutoCollect()
    end

    -- 等待3秒让角色完全加载
    task.wait(3)
    
    -- 重要修复：确保地图加载完成后再应用碰撞禁用
    local mapLoaded = false
    for i = 1, 10 do
        local mapFolder = Workspace:FindFirstChild("Map")
        if mapFolder and #mapFolder:GetChildren() > 0 then
            mapLoaded = true
            print("[重生] 地图已加载，开始重新应用碰撞禁用")
            break
        end
        print("[重生] 等待地图加载... (" .. i .. "/10)")
        task.wait(1)
    end
    
    -- 如果碰撞之前是禁用的，重新应用
    if wasCollisionDisabled then
        print("[重生] 重新应用地图碰撞禁用...")
        
        -- 关键修复：等待地图完全加载，然后重新应用碰撞禁用
        if mapLoaded then
            -- 先清理之前的碰撞状态（如果还有残留）
            enableAllCollisionInMap() -- 先恢复到原始状态
            
            -- 等待0.5秒确保清理完成
            task.wait(0.5)
            
            -- 重新应用碰撞禁用
            local success = disableAllCollisionInMap()
            if success then
                print("[重生] 地图碰撞禁用重新应用成功")
            else
                print("[重生] 地图碰撞禁用重新应用失败")
            end
        else
            print("[重生] 警告：地图未完全加载，跳过碰撞禁用恢复")
            
            -- 启动一个延迟任务，稍后重新尝试
            task.spawn(function()
                task.wait(5)
                local mapFolder = Workspace:FindFirstChild("Map")
                if mapFolder then
                    print("[重生] 延迟恢复碰撞禁用...")
                    enableAllCollisionInMap() -- 先清理
                    task.wait(0.5)
                    disableAllCollisionInMap()
                end
            end)
        end
    end
    
    -- 恢复目标模式
    HerbState.targetMode = currentTargetMode
    
    -- 根据重生前的状态重新启动系统
    print("[重生] 恢复重生前的系统状态...")
    
    -- 恢复功法自动收集
    if wasAuraAutoCollectEnabled and not AuraAutoCollectState.enabled then
        print("[重生] 恢复功法自动收集")
        toggleAuraAutoCollect()
    end
    
    -- 恢复自动采摘
    if wasAutoHarvestEnabled and not HerbState.autoHarvestEnabled then
        print("[重生] 恢复自动采摘")
        toggleAutoHarvest()
    end
    
    -- 恢复一键加速
    if wasQuickPickEnabled and not HerbState.quickPickEnabled then
        print("[重生] 恢复一键加速")
        toggleQuickPick()
    end
    
    -- 恢复修炼状态
    if wasCultivating and not CultState.isCultivating then
        print("[重生] 恢复修炼状态")
        toggleCultivation()
        
        -- 恢复自动突破
        if wasAutoBreakthrough and not CultState.isAutoBreakthrough then
            print("[重生] 恢复自动突破")
            startAutoBreakthrough()
        end
    end
    
    -- 恢复草药系统
    if wasHerbRunningBeforeDeath and not HerbState.isRunning then
        print("[重生] 恢复草药采集系统")
        startHerbSystem()
    end
    
    -- 恢复炼药系统
    if wasCrafting and not PillState.isCrafting then
        print("[重生] 恢复炼药系统")
        startCraftPills(PillState.currentPillType, PillState.craftCount)
    end
    
    -- 重新创建UI
    task.wait(1)
    
    if MainUI then
        MainUI:Destroy()
        MainUI = nil
    end
    
    -- 重新创建移动端按钮
    if MobileToggleGUI then
        MobileToggleGUI:Destroy()
        MobileToggleGUI = nil
    end
    createMobileToggle()
    
    createMainUI()
    
    -- 重要修复：防AFK系统应该一直运行，不要停止或重启
    -- 如果防AFK连接意外断开，重新启动它
    if not AntiAFKState.isRunning or not AntiAFKState.connection then
        print("[重生] 检测到防AFK系统停止，重新启动")
        setupAntiAFK()
    else
        print("[重生] 防AFK系统正在运行，无需重启")
    end
    
    -- 重新设置输入监控
    setupGameInputMonitoring()
    
    print("[重生] 系统已重置并恢复状态")
    
    -- 更新UI按钮状态
    if MainUI and MainUI.Enabled then
        -- 更新UI显示状态
        task.wait(0.5)
        
        -- 关键修复：更新碰撞禁用按钮状态
        local herbCollisionButton = MainUI:FindFirstChild("MainFrame", true):FindFirstChild("HerbCollisionButton", true)
        if herbCollisionButton then
            if CollisionState.isCollisionDisabled then
                herbCollisionButton.Text = "已禁用碰撞"
                herbCollisionButton.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
            else
                herbCollisionButton.Text = "禁用地图碰撞"
                herbCollisionButton.BackgroundColor3 = Color3.fromRGB(120, 70, 150)
            end
        end
        
        print("[重生] UI状态已更新")
    end
end)


-- ===================== 修复地图碰撞禁用的定期检查和恢复 =====================
task.spawn(function()
    while true do
        task.wait(30) -- 每30秒检查一次碰撞状态
        
        if CollisionState.isCollisionDisabled then
            -- 检查是否有部分对象的碰撞被恢复了
            local anyCollisionEnabled = false
            local restoredCount = 0
            
            for part, originalState in pairs(CollisionState.originalCollisionStates) do
                if part and part.Parent and part.CanCollide == true then
                    anyCollisionEnabled = true
                    restoredCount = restoredCount + 1
                    
                    -- 重新禁用碰撞
                    pcall(function()
                        part.CanCollide = false
                    end)
                end
            end
            
            if anyCollisionEnabled and restoredCount > 0 then
                print("[碰撞检查] 检测到 " .. restoredCount .. " 个对象碰撞被恢复，已重新禁用")
            end
        end
    end
end)

-- ===================== 定期清理和重置机制 =====================
-- 每30分钟强制清理一次状态，防止长时间运行导致的问题
task.spawn(function()
    while true do
        task.wait(1800) -- 30分钟
        
        if not AntiAFKState.isRunning or not AntiAFKState.connection then
            print("[系统检查] 防AFK系统停止，正在重新启动...")
            setupAntiAFK()
        end
        
        -- 打印防AFK状态
        local currentTime = tick()
        local timeSinceLastInput = currentTime - AntiAFKState.lastInputTime
        local timeSinceLastSignal = currentTime - AntiAFKState.lastAFKSignalTime
        
        if timeSinceLastInput > 30 then
            print("[系统检查] 警告: 已 " .. math.floor(timeSinceLastInput) .. " 秒无模拟输入")
        end
        
        if timeSinceLastSignal > 35 then
            print("[系统检查] 警告: 已 " .. math.floor(timeSinceLastSignal) .. " 秒无活动信号")
        end

        if HerbState.isRunning then
            print("[定期清理] 执行定期状态清理...")
            
            -- 清理过期的缓存
            local currentTime = tick()
            for herb, cacheTime in pairs(HerbState.herbAgeCache) do
                if currentTime - cacheTime > 600 then -- 10分钟前的缓存
                    HerbState.herbAgeCache[herb] = nil
                end
            end
            
            -- 清理过期的超时记录
            for herb, timeoutTime in pairs(HerbState.timeoutHerbs) do
                if currentTime - timeoutTime > CONFIG.TIMEOUT_COOLDOWN then
                    HerbState.timeoutHerbs[herb] = nil
                end
            end
            
            -- 清理过期的修改记录
            for herb, _ in pairs(HerbState.modifiedHerbs) do
                if not herb or not herb.Parent then
                    HerbState.modifiedHerbs[herb] = nil
                end
            end
            
            -- 如果当前目标为空或无效，强制重新寻找
            if HerbState.currentHerb and (not HerbState.currentHerb.Parent or not HerbState.currentHerb:IsDescendantOf(Workspace)) then
                print("[定期清理] 当前目标无效，强制重新寻找")
                HerbState.currentHerb = nil
            end
            
            print("[定期清理] 完成状态清理")
        end
    end
end)

print("=== 系统初始化完成 ===")
